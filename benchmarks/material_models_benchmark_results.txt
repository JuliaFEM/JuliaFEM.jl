================================================================================
Material Models Performance Benchmark (Extended)
================================================================================


================================================================================
NEWTON ITERATION STATE HANDLING EXAMPLE
================================================================================

Example 1: Stateless Material (LinearElastic)
--------------------------------------------------------------------------------
  Newton iteration with material state tracking:
  ============================================================
  Iteration 1:
    strain: 0.0
    stress: 0.0
    state:  NoState()
  Iteration 2:
    strain: 0.0005
    stress: 1.5741063022831637e8
    state:  NoState()
  Iteration 3:
    strain: 0.00075
    stress: 2.3611594534247452e8
    state:  NoState()
  â†’ Failed to converge!
  State NOT committed (keeping state_old)
Result: state_final = NoState() (NoState, always)

Example 2: Stateful Material (PerfectPlasticity)
--------------------------------------------------------------------------------
  Newton iteration with material state tracking:
  ============================================================
  Iteration 1:
    strain: 0.0
    stress: 0.0
    state:  PlasticityState{Float64}([0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], 0.0)
  Iteration 2:
    strain: 0.001
    stress: 3.1482126045663273e8
    state:  PlasticityState{Float64}([0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], 0.0)
  Iteration 3:
    strain: 0.0015
    stress: 4.7223189068494904e8
    state:  PlasticityState{Float64}([0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], 0.0)
  â†’ Failed to converge!
  State NOT committed (keeping state_old)
Result: state_final = PlasticityState{Float64}([0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0], 0.0) (plastic strain accumulated)

Key insight: State handling is IDENTICAL for all materials due to
AbstractMaterialState type hierarchy. Assembly code doesn't need
to know whether material is stateless or stateful!

Setting up materials and test cases...

Materials configured:
  - Linear Elastic: E = 200 GPa, Î½ = 0.3
  - Neo-Hookean (AD): Î¼ â‰ˆ 3.4 MPa, Î» â‰ˆ 45 MPa (automatic differentiation)
  - Neo-Hookean (Manual): Î¼ â‰ˆ 3.4 MPa, Î» â‰ˆ 45 MPa (hand-coded derivatives)
  - Perfect Plasticity: E = 200 GPa, Ïƒ_y = 250 MPa

Test strain: Îµ11 = 0.001 (uniaxial tension)

================================================================================
TYPE STABILITY ANALYSIS
================================================================================

Checking for type instabilities...

1. Linear Elastic (Tensors.jl):
MethodInstance for compute_stress(::LinearElastic, ::SymmetricTensor{2, 3, Float64, 6}, ::NoState, ::Float64)
  from compute_stress(material::LinearElastic, Îµ::SymmetricTensor{2, 3, T}, state_old::NoState, Î”t::Float64) where T @ Main ~/dev/JuliaFEM.jl/benchmarks/material_models_benchmark.jl:94
Static Parameters
  T = Float64
Arguments
  #self#::Core.Const(Main.compute_stress)
  material::LinearElastic
  Îµ::SymmetricTensor{2, 3, Float64, 6}
  state_old::Core.Const(NoState())
  Î”t::Float64
Locals
  ğ”»::SymmetricTensor{4, 3, Float64, 36}
  ğ•€Ë¢Ê¸áµ::SymmetricTensor{4, 3, Float64, 36}
  Ïƒ::SymmetricTensor{2, 3, Float64, 6}
  I::SymmetricTensor{2, 3, Float64, 6}
  Î¼_val::Float64
  Î»_val::Float64
Body::Tuple{SymmetricTensor{2, 3, Float64, 6}, SymmetricTensor{4, 3, Float64, 36}, NoState}
1 â”€ %1  = Main.Î»::Core.Const(Main.Î»)
â”‚         (Î»_val = (%1)(material))
â”‚   %3  = Main.Î¼::Core.Const(Main.Î¼)
â”‚         (Î¼_val = (%3)(material))
â”‚   %5  = Main.one::Core.Const(one)
â”‚         (I = (%5)(Îµ))
â”‚   %7  = Main.:+::Core.Const(+)
â”‚   %8  = Main.:*::Core.Const(*)
â”‚   %9  = Î»_val::Float64
â”‚   %10 = Main.tr::Core.Const(LinearAlgebra.tr)
â”‚   %11 = (%10)(Îµ)::Float64
â”‚   %12 = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚   %13 = (%8)(%9, %11, %12)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %14 = Main.:*::Core.Const(*)
â”‚   %15 = Main.:*::Core.Const(*)
â”‚   %16 = Î¼_val::Float64
â”‚   %17 = (%15)(2, %16)::Float64
â”‚   %18 = (%14)(%17, Îµ)::SymmetricTensor{2, 3, Float64, 6}
â”‚         (Ïƒ = (%7)(%13, %18))
â”‚   %20 = Main.one::Core.Const(one)
â”‚   %21 = Main.SymmetricTensor::Core.Const(SymmetricTensor)
â”‚   %22 = $(Expr(:static_parameter, 1))::Core.Const(Float64)
â”‚   %23 = Core.apply_type(%21, 4, 3, %22)::Core.Const(SymmetricTensor{4, 3, Float64})
â”‚         (ğ•€Ë¢Ê¸áµ = (%20)(%23))
â”‚   %25 = Main.:+::Core.Const(+)
â”‚   %26 = Main.:âŠ—::Core.Const(Tensors.otimes)
â”‚   %27 = Main.:*::Core.Const(*)
â”‚   %28 = Î»_val::Float64
â”‚   %29 = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚   %30 = (%27)(%28, %29)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %31 = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚   %32 = (%26)(%30, %31)::SymmetricTensor{4, 3, Float64, 36}
â”‚   %33 = Main.:*::Core.Const(*)
â”‚   %34 = Main.:*::Core.Const(*)
â”‚   %35 = Î¼_val::Float64
â”‚   %36 = (%34)(2, %35)::Float64
â”‚   %37 = ğ•€Ë¢Ê¸áµ::Core.Const([1.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.0 0.5 0.0; 0.5 0.0 0.0; 0.0 0.0 0.0;;; 0.0 0.0 0.5; 0.0 0.0 0.0; 0.5 0.0 0.0;;;; 0.0 0.5 0.0; 0.5 0.0 0.0; 0.0 0.0 0.0;;; 0.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 0.0;;; 0.0 0.0 0.0; 0.0 0.0 0.5; 0.0 0.5 0.0;;;; 0.0 0.0 0.5; 0.0 0.0 0.0; 0.5 0.0 0.0;;; 0.0 0.0 0.0; 0.0 0.0 0.5; 0.0 0.5 0.0;;; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 1.0])
â”‚   %38 = (%33)(%36, %37)::SymmetricTensor{4, 3, Float64, 36}
â”‚         (ğ”» = (%25)(%32, %38))
â”‚   %40 = Ïƒ::SymmetricTensor{2, 3, Float64, 6}
â”‚   %41 = ğ”»::SymmetricTensor{4, 3, Float64, 36}
â”‚   %42 = Main.NoState::Core.Const(NoState)
â”‚   %43 = (%42)()::Core.Const(NoState())
â”‚   %44 = Core.tuple(%40, %41, %43)::Tuple{SymmetricTensor{2, 3, Float64, 6}, SymmetricTensor{4, 3, Float64, 36}, NoState}
â””â”€â”€       return %44


2. Linear Elastic (Old Voigt/Dict):
MethodInstance for compute_stress_old(::LinearElasticOld, ::Vector{Float64}, ::Dict{String, Any}, ::Float64)
  from compute_stress_old(material::LinearElasticOld, Îµ_vec::Vector{Float64}, state_old::Dict{String, Any}, Î”t::Float64) @ Main ~/dev/JuliaFEM.jl/benchmarks/material_models_benchmark.jl:413
Arguments
  #self#::Core.Const(Main.compute_stress_old)
  material::LinearElasticOld
  Îµ_vec::Vector{Float64}
  state_old::Dict{String, Any}
  Î”t::Float64
Locals
  Ïƒ_vec::Vector{Float64}
  D::Matrix{Float64}
Body::Tuple{Vector{Float64}, Matrix{Float64}, Dict{String, Any}}
1 â”€ %1 = Main.constitutive_matrix::Core.Const(Main.constitutive_matrix)
â”‚        (D = (%1)(material))
â”‚   %3 = Main.:*::Core.Const(*)
â”‚   %4 = D::Matrix{Float64}
â”‚        (Ïƒ_vec = (%3)(%4, Îµ_vec))
â”‚   %6 = Ïƒ_vec::Vector{Float64}
â”‚   %7 = D::Matrix{Float64}
â”‚   %8 = Core.tuple(%6, %7, state_old)::Tuple{Vector{Float64}, Matrix{Float64}, Dict{String, Any}}
â””â”€â”€      return %8


3. Neo-Hookean AD (Tensors.jl with automatic differentiation):
MethodInstance for compute_stress(::NeoHookeanAD, ::SymmetricTensor{2, 3, Float64, 6}, ::NoState, ::Float64)
  from compute_stress(material::NeoHookeanAD, E::SymmetricTensor{2, 3, T}, state_old::NoState, Î”t::Float64) where T @ Main ~/dev/JuliaFEM.jl/benchmarks/material_models_benchmark.jl:147
Static Parameters
  T = Float64
Arguments
  #self#::Core.Const(Main.compute_stress)
  material::NeoHookeanAD
  E::SymmetricTensor{2, 3, Float64, 6}
  state_old::Core.Const(NoState())
  Î”t::Float64
Locals
  @_6::Int64
  S::SymmetricTensor{2, 3, Float64, 6}
  ğ”»::SymmetricTensor{4, 3, Float64, 36}
  Ïˆ::var"#Ïˆ#compute_stress##0"{NeoHookeanAD}
  C::SymmetricTensor{2, 3, Float64, 6}
  I::SymmetricTensor{2, 3, Float64, 6}
Body::Tuple{SymmetricTensor{2, 3, Float64, 6}, SymmetricTensor{4, 3, Float64, 36}, NoState}
1 â”€ %1  = Main.one::Core.Const(one)
â”‚         (I = (%1)(E))
â”‚   %3  = Main.:+::Core.Const(+)
â”‚   %4  = Main.:*::Core.Const(*)
â”‚   %5  = (%4)(2, E)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %6  = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚         (C = (%3)(%5, %6))
â”‚   %8  = Main.:(var"#Ïˆ#compute_stress##0")::Core.Const(var"#Ïˆ#compute_stress##0")
â”‚   %9  = Core._typeof_captured_variable(material)::Core.Const(NeoHookeanAD)
â”‚   %10 = Core.apply_type(%8, %9)::Core.Const(var"#Ïˆ#compute_stress##0"{NeoHookeanAD})
â”‚         (Ïˆ = %new(%10, material))
â”‚   %12 = Main.hessian::Core.Const(Tensors.hessian)
â”‚   %13 = Ïˆ::var"#Ïˆ#compute_stress##0"{NeoHookeanAD}
â”‚   %14 = C::SymmetricTensor{2, 3, Float64, 6}
â”‚   %15 = (%12)(%13, %14, :all)::Tuple{SymmetricTensor{4, 3, Float64, 36}, SymmetricTensor{2, 3, Float64, 6}, Float64}
â”‚   %16 = Base.indexed_iterate(%15, 1)::Core.PartialStruct(Tuple{SymmetricTensor{4, 3, Float64, 36}, Int64}, Any[SymmetricTensor{4, 3, Float64, 36}, Core.Const(2)])
â”‚         (ğ”» = Core.getfield(%16, 1))
â”‚         (@_6 = Core.getfield(%16, 2))
â”‚   %19 = @_6::Core.Const(2)
â”‚   %20 = Base.indexed_iterate(%15, 2, %19)::Core.PartialStruct(Tuple{SymmetricTensor{2, 3, Float64, 6}, Int64}, Any[SymmetricTensor{2, 3, Float64, 6}, Core.Const(3)])
â”‚         (S = Core.getfield(%20, 1))
â”‚   %22 = Main.:*::Core.Const(*)
â”‚   %23 = S::SymmetricTensor{2, 3, Float64, 6}
â”‚         (S = (%22)(2, %23))
â”‚   %25 = Main.:*::Core.Const(*)
â”‚   %26 = ğ”»::SymmetricTensor{4, 3, Float64, 36}
â”‚         (ğ”» = (%25)(4, %26))
â”‚   %28 = S::SymmetricTensor{2, 3, Float64, 6}
â”‚   %29 = ğ”»::SymmetricTensor{4, 3, Float64, 36}
â”‚   %30 = Main.NoState::Core.Const(NoState)
â”‚   %31 = (%30)()::Core.Const(NoState())
â”‚   %32 = Core.tuple(%28, %29, %31)::Tuple{SymmetricTensor{2, 3, Float64, 6}, SymmetricTensor{4, 3, Float64, 36}, NoState}
â””â”€â”€       return %32


4. Neo-Hookean Manual (Tensors.jl with hand-coded derivatives):
MethodInstance for compute_stress(::NeoHookeanManual, ::SymmetricTensor{2, 3, Float64, 6}, ::NoState, ::Float64)
  from compute_stress(material::NeoHookeanManual, E::SymmetricTensor{2, 3, T}, state_old::NoState, Î”t::Float64) where T @ Main ~/dev/JuliaFEM.jl/benchmarks/material_models_benchmark.jl:203
Static Parameters
  T = Float64
Arguments
  #self#::Core.Const(Main.compute_stress)
  material::NeoHookeanManual
  E::SymmetricTensor{2, 3, Float64, 6}
  state_old::Core.Const(NoState())
  Î”t::Float64
Locals
  ğ”»::SymmetricTensor{4, 3, Float64, 36}
  ğ”»â‚‚::SymmetricTensor{4, 3, Float64, 36}
  coeff::Float64
  ğ•€Ë¢Ê¸áµ::SymmetricTensor{4, 3, Float64, 36}
  ğ”»â‚::SymmetricTensor{4, 3, Float64, 36}
  S::SymmetricTensor{2, 3, Float64, 6}
  C_inv::SymmetricTensor{2, 3, Float64, 6}
  J::Float64
  C::SymmetricTensor{2, 3, Float64, 6}
  I::SymmetricTensor{2, 3, Float64, 6}
  Î»::Float64
  Î¼::Float64
Body::Tuple{SymmetricTensor{2, 3, Float64, 6}, SymmetricTensor{4, 3, Float64, 36}, NoState}
1 â”€ %1  = Base.getproperty(material, :Î¼)::Float64
â”‚   %2  = Base.getproperty(material, :Î»)::Float64
â”‚         (Î¼ = %1)
â”‚         (Î» = %2)
â”‚   %5  = Main.one::Core.Const(one)
â”‚         (I = (%5)(E))
â”‚   %7  = Main.:+::Core.Const(+)
â”‚   %8  = Main.:*::Core.Const(*)
â”‚   %9  = (%8)(2, E)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %10 = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚         (C = (%7)(%9, %10))
â”‚   %12 = Main.:âˆš::Core.Const(sqrt)
â”‚   %13 = Main.det::Core.Const(LinearAlgebra.det)
â”‚   %14 = C::SymmetricTensor{2, 3, Float64, 6}
â”‚   %15 = (%13)(%14)::Float64
â”‚         (J = (%12)(%15))
â”‚   %17 = Main.inv::Core.Const(inv)
â”‚   %18 = C::SymmetricTensor{2, 3, Float64, 6}
â”‚         (C_inv = (%17)(%18))
â”‚   %20 = Main.:+::Core.Const(+)
â”‚   %21 = Main.:*::Core.Const(*)
â”‚   %22 = Î¼::Float64
â”‚   %23 = Main.:-::Core.Const(-)
â”‚   %24 = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚   %25 = C_inv::SymmetricTensor{2, 3, Float64, 6}
â”‚   %26 = (%23)(%24, %25)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %27 = (%21)(%22, %26)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %28 = Main.:*::Core.Const(*)
â”‚   %29 = Î»::Float64
â”‚   %30 = Main.log::Core.Const(log)
â”‚   %31 = J::Float64
â”‚   %32 = (%30)(%31)::Float64
â”‚   %33 = C_inv::SymmetricTensor{2, 3, Float64, 6}
â”‚   %34 = (%28)(%29, %32, %33)::SymmetricTensor{2, 3, Float64, 6}
â”‚         (S = (%20)(%27, %34))
â”‚   %36 = Main.:*::Core.Const(*)
â”‚   %37 = Î»::Float64
â”‚   %38 = Main.:âŠ—::Core.Const(Tensors.otimes)
â”‚   %39 = C_inv::SymmetricTensor{2, 3, Float64, 6}
â”‚   %40 = C_inv::SymmetricTensor{2, 3, Float64, 6}
â”‚   %41 = (%38)(%39, %40)::SymmetricTensor{4, 3, Float64, 36}
â”‚         (ğ”»â‚ = (%36)(%37, %41))
â”‚   %43 = Main.one::Core.Const(one)
â”‚   %44 = Main.SymmetricTensor::Core.Const(SymmetricTensor)
â”‚   %45 = $(Expr(:static_parameter, 1))::Core.Const(Float64)
â”‚   %46 = Core.apply_type(%44, 4, 3, %45)::Core.Const(SymmetricTensor{4, 3, Float64})
â”‚         (ğ•€Ë¢Ê¸áµ = (%43)(%46))
â”‚   %48 = Main.:*::Core.Const(*)
â”‚   %49 = Main.:-::Core.Const(-)
â”‚   %50 = Î¼::Float64
â”‚   %51 = Main.:*::Core.Const(*)
â”‚   %52 = Î»::Float64
â”‚   %53 = Main.log::Core.Const(log)
â”‚   %54 = J::Float64
â”‚   %55 = (%53)(%54)::Float64
â”‚   %56 = (%51)(%52, %55)::Float64
â”‚   %57 = (%49)(%50, %56)::Float64
â”‚         (coeff = (%48)(2, %57))
â”‚   %59 = Main.:*::Core.Const(*)
â”‚   %60 = Main.:-::Core.Const(-)
â”‚   %61 = coeff::Float64
â”‚   %62 = (%60)(%61)::Float64
â”‚   %63 = Main.inv_symmetric_outer::Core.Const(Main.inv_symmetric_outer)
â”‚   %64 = C_inv::SymmetricTensor{2, 3, Float64, 6}
â”‚   %65 = (%63)(%64)::SymmetricTensor{4, 3, Float64, 36}
â”‚         (ğ”»â‚‚ = (%59)(%62, %65))
â”‚   %67 = Main.:+::Core.Const(+)
â”‚   %68 = ğ”»â‚::SymmetricTensor{4, 3, Float64, 36}
â”‚   %69 = ğ”»â‚‚::SymmetricTensor{4, 3, Float64, 36}
â”‚         (ğ”» = (%67)(%68, %69))
â”‚   %71 = S::SymmetricTensor{2, 3, Float64, 6}
â”‚   %72 = ğ”»::SymmetricTensor{4, 3, Float64, 36}
â”‚   %73 = Main.NoState::Core.Const(NoState)
â”‚   %74 = (%73)()::Core.Const(NoState())
â”‚   %75 = Core.tuple(%71, %72, %74)::Tuple{SymmetricTensor{2, 3, Float64, 6}, SymmetricTensor{4, 3, Float64, 36}, NoState}
â””â”€â”€       return %75


5. Perfect Plasticity (Tensors.jl):
MethodInstance for compute_stress(::PerfectPlasticity, ::SymmetricTensor{2, 3, Float64, 6}, ::PlasticityState{Float64}, ::Float64)
  from compute_stress(material::PerfectPlasticity, Îµ::SymmetricTensor{2, 3, T}, state_old::PlasticityState{T}, Î”t::Float64) where T @ Main ~/dev/JuliaFEM.jl/benchmarks/material_models_benchmark.jl:328
Static Parameters
  T = Float64
Arguments
  #self#::Core.Const(Main.compute_stress)
  material::PerfectPlasticity
  Îµ::SymmetricTensor{2, 3, Float64, 6}
  state_old::PlasticityState{Float64}
  Î”t::Float64
Locals
  ğ”»::SymmetricTensor{4, 3, Float64, 36}
  Î²::Float64
  Î¸::Float64
  state_new::PlasticityState{Float64}
  Î±_new::Float64
  Îµ_p_new::SymmetricTensor{2, 3, Float64, 6}
  n::SymmetricTensor{2, 3, Float64, 6}
  Î”Î³::Float64
  Ïƒ::SymmetricTensor{2, 3, Float64, 6}
  p::Float64
  s_trial::SymmetricTensor{2, 3, Float64, 6}
  f::Float64
  Ïƒ_eq_trial::Float64
  Ïƒ_trial::SymmetricTensor{2, 3, Float64, 6}
  Îµ_e::SymmetricTensor{2, 3, Float64, 6}
  ğ”»áµ‰::SymmetricTensor{4, 3, Float64, 36}
  ğ•€Ë¢Ê¸áµ::SymmetricTensor{4, 3, Float64, 36}
  I::SymmetricTensor{2, 3, Float64, 6}
  Ïƒ_y::Float64
  Î¼_val::Float64
  Î»_val::Float64
Body::Tuple{SymmetricTensor{2, 3, Float64, 6}, SymmetricTensor{4, 3, Float64, 36}, PlasticityState{Float64}}
1 â”€        Core.NewvarNode(:(ğ”»))
â”‚          Core.NewvarNode(:(Î²))
â”‚          Core.NewvarNode(:(Î¸))
â”‚          Core.NewvarNode(:(state_new))
â”‚          Core.NewvarNode(:(Î±_new))
â”‚          Core.NewvarNode(:(Îµ_p_new))
â”‚          Core.NewvarNode(:(n))
â”‚          Core.NewvarNode(:(Î”Î³))
â”‚          Core.NewvarNode(:(Ïƒ))
â”‚          Core.NewvarNode(:(p))
â”‚          Core.NewvarNode(:(s_trial))
â”‚   %12  = Main.Î»::Core.Const(Main.Î»)
â”‚          (Î»_val = (%12)(material))
â”‚   %14  = Main.Î¼::Core.Const(Main.Î¼)
â”‚          (Î¼_val = (%14)(material))
â”‚          (Ïƒ_y = Base.getproperty(material, :Ïƒ_y))
â”‚   %17  = Main.one::Core.Const(one)
â”‚          (I = (%17)(Îµ))
â”‚   %19  = Main.one::Core.Const(one)
â”‚   %20  = Main.SymmetricTensor::Core.Const(SymmetricTensor)
â”‚   %21  = $(Expr(:static_parameter, 1))::Core.Const(Float64)
â”‚   %22  = Core.apply_type(%20, 4, 3, %21)::Core.Const(SymmetricTensor{4, 3, Float64})
â”‚          (ğ•€Ë¢Ê¸áµ = (%19)(%22))
â”‚   %24  = Main.:+::Core.Const(+)
â”‚   %25  = Main.:âŠ—::Core.Const(Tensors.otimes)
â”‚   %26  = Main.:*::Core.Const(*)
â”‚   %27  = Î»_val::Float64
â”‚   %28  = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚   %29  = (%26)(%27, %28)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %30  = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚   %31  = (%25)(%29, %30)::SymmetricTensor{4, 3, Float64, 36}
â”‚   %32  = Main.:*::Core.Const(*)
â”‚   %33  = Main.:*::Core.Const(*)
â”‚   %34  = Î¼_val::Float64
â”‚   %35  = (%33)(2, %34)::Float64
â”‚   %36  = ğ•€Ë¢Ê¸áµ::Core.Const([1.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0;;; 0.0 0.5 0.0; 0.5 0.0 0.0; 0.0 0.0 0.0;;; 0.0 0.0 0.5; 0.0 0.0 0.0; 0.5 0.0 0.0;;;; 0.0 0.5 0.0; 0.5 0.0 0.0; 0.0 0.0 0.0;;; 0.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 0.0;;; 0.0 0.0 0.0; 0.0 0.0 0.5; 0.0 0.5 0.0;;;; 0.0 0.0 0.5; 0.0 0.0 0.0; 0.5 0.0 0.0;;; 0.0 0.0 0.0; 0.0 0.0 0.5; 0.0 0.5 0.0;;; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 1.0])
â”‚   %37  = (%32)(%35, %36)::SymmetricTensor{4, 3, Float64, 36}
â”‚          (ğ”»áµ‰ = (%24)(%31, %37))
â”‚   %39  = Main.:-::Core.Const(-)
â”‚   %40  = Base.getproperty(state_old, :Îµ_p)::SYMMETRICTENSOR{2, 3, FLOAT64}
â”‚          (Îµ_e = (%39)(Îµ, %40))
â”‚   %42  = Main.:+::Core.Const(+)
â”‚   %43  = Main.:*::Core.Const(*)
â”‚   %44  = Î»_val::Float64
â”‚   %45  = Main.tr::Core.Const(LinearAlgebra.tr)
â”‚   %46  = Îµ_e::SymmetricTensor{2, 3, Float64, 6}
â”‚   %47  = (%45)(%46)::Float64
â”‚   %48  = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚   %49  = (%43)(%44, %47, %48)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %50  = Main.:*::Core.Const(*)
â”‚   %51  = Main.:*::Core.Const(*)
â”‚   %52  = Î¼_val::Float64
â”‚   %53  = (%51)(2, %52)::Float64
â”‚   %54  = Îµ_e::SymmetricTensor{2, 3, Float64, 6}
â”‚   %55  = (%50)(%53, %54)::SymmetricTensor{2, 3, Float64, 6}
â”‚          (Ïƒ_trial = (%42)(%49, %55))
â”‚   %57  = Main.von_mises_stress::Core.Const(Main.von_mises_stress)
â”‚   %58  = Ïƒ_trial::SymmetricTensor{2, 3, Float64, 6}
â”‚          (Ïƒ_eq_trial = (%57)(%58))
â”‚   %60  = Main.:-::Core.Const(-)
â”‚   %61  = Ïƒ_eq_trial::Float64
â”‚   %62  = Ïƒ_y::Float64
â”‚          (f = (%60)(%61, %62))
â”‚   %64  = Main.:â‰¤::Core.Const(<=)
â”‚   %65  = f::Float64
â”‚   %66  = (%64)(%65, 0.0)::Bool
â””â”€â”€        goto #3 if not %66
2 â”€ %68  = Ïƒ_trial::SymmetricTensor{2, 3, Float64, 6}
â”‚          (Ïƒ = %68)
â”‚   %70  = ğ”»áµ‰::SymmetricTensor{4, 3, Float64, 36}
â”‚          (ğ”» = %70)
â”‚   %72  = state_old::PlasticityState{Float64}
â”‚          (state_new = %72)
â””â”€â”€        goto #4
3 â”€ %75  = Main.dev::Core.Const(Tensors.dev)
â”‚   %76  = Ïƒ_trial::SymmetricTensor{2, 3, Float64, 6}
â”‚          (s_trial = (%75)(%76))
â”‚   %78  = Main.:/::Core.Const(/)
â”‚   %79  = Main.tr::Core.Const(LinearAlgebra.tr)
â”‚   %80  = Ïƒ_trial::SymmetricTensor{2, 3, Float64, 6}
â”‚   %81  = (%79)(%80)::Float64
â”‚          (p = (%78)(%81, 3))
â”‚   %83  = Main.:+::Core.Const(+)
â”‚   %84  = Main.:*::Core.Const(*)
â”‚   %85  = p::Float64
â”‚   %86  = I::Core.Const([1.0 0.0 0.0; 0.0 1.0 0.0; 0.0 0.0 1.0])
â”‚   %87  = (%84)(%85, %86)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %88  = Main.:*::Core.Const(*)
â”‚   %89  = Main.:/::Core.Const(/)
â”‚   %90  = Ïƒ_y::Float64
â”‚   %91  = Ïƒ_eq_trial::Float64
â”‚   %92  = (%89)(%90, %91)::Float64
â”‚   %93  = s_trial::SymmetricTensor{2, 3, Float64, 6}
â”‚   %94  = (%88)(%92, %93)::SymmetricTensor{2, 3, Float64, 6}
â”‚          (Ïƒ = (%83)(%87, %94))
â”‚   %96  = Main.:/::Core.Const(/)
â”‚   %97  = f::Float64
â”‚   %98  = Main.:*::Core.Const(*)
â”‚   %99  = Î¼_val::Float64
â”‚   %100 = (%98)(3, %99)::Float64
â”‚          (Î”Î³ = (%96)(%97, %100))
â”‚   %102 = Main.:/::Core.Const(/)
â”‚   %103 = Main.:*::Core.Const(*)
â”‚   %104 = Main.:âˆš::Core.Const(sqrt)
â”‚   %105 = Main.:/::Core.Const(/)
â”‚   %106 = (%105)(3, 2)::Core.Const(1.5)
â”‚   %107 = (%104)(%106)::Core.Const(1.224744871391589)
â”‚   %108 = s_trial::SymmetricTensor{2, 3, Float64, 6}
â”‚   %109 = (%103)(%107, %108)::SymmetricTensor{2, 3, Float64, 6}
â”‚   %110 = Ïƒ_eq_trial::Float64
â”‚          (n = (%102)(%109, %110))
â”‚   %112 = Main.:+::Core.Const(+)
â”‚   %113 = Base.getproperty(state_old, :Îµ_p)::SYMMETRICTENSOR{2, 3, FLOAT64}
â”‚   %114 = Main.:*::Core.Const(*)
â”‚   %115 = Î”Î³::Float64
â”‚   %116 = n::SymmetricTensor{2, 3, Float64, 6}
â”‚   %117 = (%114)(%115, %116)::SymmetricTensor{2, 3, Float64, 6}
â”‚          (Îµ_p_new = (%112)(%113, %117))
â”‚   %119 = Main.:+::Core.Const(+)
â”‚   %120 = Base.getproperty(state_old, :Î±)::Float64
â”‚   %121 = Î”Î³::Float64
â”‚          (Î±_new = (%119)(%120, %121))
â”‚   %123 = Main.PlasticityState::Core.Const(PlasticityState)
â”‚   %124 = Îµ_p_new::SymmetricTensor{2, 3, Float64, 6}
â”‚   %125 = Î±_new::Float64
â”‚          (state_new = (%123)(%124, %125))
â”‚   %127 = Main.:-::Core.Const(-)
â”‚   %128 = Main.:/::Core.Const(/)
â”‚   %129 = Ïƒ_y::Float64
â”‚   %130 = Ïƒ_eq_trial::Float64
â”‚   %131 = (%128)(%129, %130)::Float64
â”‚          (Î¸ = (%127)(1, %131))
â”‚   %133 = Main.:/::Core.Const(/)
â”‚   %134 = Main.:*::Core.Const(*)
â”‚   %135 = Main.:^::Core.Const(^)
â”‚   %136 = Î¼_val::Float64
â”‚   %137 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
â”‚   %138 = (%137)()::Core.Const(Val{2}())
â”‚   %139 = Base.literal_pow(%135, %136, %138)::Float64
â”‚   %140 = (%134)(6, %139)::Float64
â”‚   %141 = Main.:+::Core.Const(+)
â”‚   %142 = Main.:*::Core.Const(*)
â”‚   %143 = Î¼_val::Float64
â”‚   %144 = (%142)(3, %143)::Float64
â”‚   %145 = Main.:*::Core.Const(*)
â”‚   %146 = Î¸::Float64
â”‚   %147 = Main.:*::Core.Const(*)
â”‚   %148 = Î¼_val::Float64
â”‚   %149 = (%147)(3, %148)::Float64
â”‚   %150 = (%145)(%146, %149)::Float64
â”‚   %151 = (%141)(%144, %150)::Float64
â”‚          (Î² = (%133)(%140, %151))
â”‚   %153 = Main.:-::Core.Const(-)
â”‚   %154 = ğ”»áµ‰::SymmetricTensor{4, 3, Float64, 36}
â”‚   %155 = Main.:*::Core.Const(*)
â”‚   %156 = Î²::Float64
â”‚   %157 = Main.:âŠ—::Core.Const(Tensors.otimes)
â”‚   %158 = n::SymmetricTensor{2, 3, Float64, 6}
â”‚   %159 = n::SymmetricTensor{2, 3, Float64, 6}
â”‚   %160 = (%157)(%158, %159)::SymmetricTensor{4, 3, Float64, 36}
â”‚   %161 = (%155)(%156, %160)::SymmetricTensor{4, 3, Float64, 36}
â””â”€â”€        (ğ”» = (%153)(%154, %161))
4 â”„ %163 = Ïƒ::SymmetricTensor{2, 3, Float64, 6}
â”‚   %164 = ğ”»::SymmetricTensor{4, 3, Float64, 36}
â”‚   %165 = state_new::PlasticityState{Float64}
â”‚   %166 = Core.tuple(%163, %164, %165)::Tuple{SymmetricTensor{2, 3, Float64, 6}, SymmetricTensor{4, 3, Float64, 36}, PlasticityState{Float64}}
â””â”€â”€        return %166


6. Perfect Plasticity (Old Dict):
MethodInstance for compute_stress_old(::PerfectPlasticityOld, ::Vector{Float64}, ::Dict{String, Any}, ::Float64)
  from compute_stress_old(material::PerfectPlasticityOld, Îµ_vec::Vector{Float64}, state_old::Dict{String, Any}, Î”t::Float64) @ Main ~/dev/JuliaFEM.jl/benchmarks/material_models_benchmark.jl:455
Arguments
  #self#::Core.Const(Main.compute_stress_old)
  material::PerfectPlasticityOld
  Îµ_vec::Vector{Float64}
  state_old::Dict{String, Any}
  Î”t::Float64
Locals
  @_6::ANY
  @_7::ANY
  Ïƒ_vec::ANY
  n_vec::ANY
  Î”Î³::ANY
  factor::ANY
  state_new::Dict{String, Any}
  f::ANY
  Ïƒ_eq::ANY
  dev_vec::ANY
  p::ANY
  s13::ANY
  s23::ANY
  s12::ANY
  s33::ANY
  s22::ANY
  s11::ANY
  Ïƒ_trial_vec::ANY
  Îµ_e_vec::ANY
  D::Matrix{Float64}
  Îµ_p_vec::ANY
Body::TUPLE{ANY, MATRIX{FLOAT64}, DICT{STRING, ANY}}
1 â”€        Core.NewvarNode(:(@_6))
â”‚          Core.NewvarNode(:(@_7))
â”‚          Core.NewvarNode(:(Ïƒ_vec))
â”‚          Core.NewvarNode(:(n_vec))
â”‚          Core.NewvarNode(:(Î”Î³))
â”‚          Core.NewvarNode(:(factor))
â”‚          Core.NewvarNode(:(state_new))
â”‚          Core.NewvarNode(:(f))
â”‚          Core.NewvarNode(:(Ïƒ_eq))
â”‚          Core.NewvarNode(:(dev_vec))
â”‚          Core.NewvarNode(:(p))
â”‚          Core.NewvarNode(:(s13))
â”‚          Core.NewvarNode(:(s23))
â”‚          Core.NewvarNode(:(s12))
â”‚          Core.NewvarNode(:(s33))
â”‚          Core.NewvarNode(:(s22))
â”‚          Core.NewvarNode(:(s11))
â”‚          Core.NewvarNode(:(Ïƒ_trial_vec))
â”‚          Core.NewvarNode(:(Îµ_e_vec))
â”‚          Core.NewvarNode(:(D))
â”‚          Core.NewvarNode(:(Îµ_p_vec))
â”‚   %22  = Main.haskey::Core.Const(haskey)
â”‚   %23  = (%22)(state_old, "epsilon_plastic")::Bool
â””â”€â”€        goto #3 if not %23
2 â”€        (Îµ_p_vec = Base.getindex(state_old, "epsilon_plastic"))
â””â”€â”€        goto #4
3 â”€ %27  = Main.zeros::Core.Const(zeros)
â””â”€â”€        (Îµ_p_vec = (%27)(6))
4 â”„ %29  = Main.constitutive_matrix::Core.Const(Main.constitutive_matrix)
â”‚   %30  = Main.LinearElasticOld::Core.Const(LinearElasticOld)
â”‚   %31  = Base.getproperty(material, :E)::Float64
â”‚   %32  = Base.getproperty(material, :Î½)::Float64
â”‚   %33  = (%30)(%31, %32)::LinearElasticOld
â”‚          (D = (%29)(%33))
â”‚   %35  = Main.:-::Core.Const(-)
â”‚   %36  = Îµ_p_vec::ANY
â”‚          (Îµ_e_vec = (%35)(Îµ_vec, %36))
â”‚   %38  = Main.:*::Core.Const(*)
â”‚   %39  = D::Matrix{Float64}
â”‚   %40  = Îµ_e_vec::ANY
â”‚          (Ïƒ_trial_vec = (%38)(%39, %40))
â”‚   %42  = Ïƒ_trial_vec::ANY
â”‚   %43  = Main.:(:)::Core.Const(Colon())
â”‚   %44  = (%43)(1, 3)::Core.Const(1:3)
â”‚   %45  = Base.getindex(%42, %44)::ANY
â”‚   %46  = Base.indexed_iterate(%45, 1)::ANY
â”‚          (s11 = Core.getfield(%46, 1))
â”‚          (@_7 = Core.getfield(%46, 2))
â”‚   %49  = @_7::ANY
â”‚   %50  = Base.indexed_iterate(%45, 2, %49)::ANY
â”‚          (s22 = Core.getfield(%50, 1))
â”‚          (@_7 = Core.getfield(%50, 2))
â”‚   %53  = @_7::ANY
â”‚   %54  = Base.indexed_iterate(%45, 3, %53)::ANY
â”‚          (s33 = Core.getfield(%54, 1))
â”‚   %56  = Ïƒ_trial_vec::ANY
â”‚   %57  = Main.:(:)::Core.Const(Colon())
â”‚   %58  = (%57)(4, 6)::Core.Const(4:6)
â”‚   %59  = Base.getindex(%56, %58)::ANY
â”‚   %60  = Base.indexed_iterate(%59, 1)::ANY
â”‚          (s12 = Core.getfield(%60, 1))
â”‚          (@_6 = Core.getfield(%60, 2))
â”‚   %63  = @_6::ANY
â”‚   %64  = Base.indexed_iterate(%59, 2, %63)::ANY
â”‚          (s23 = Core.getfield(%64, 1))
â”‚          (@_6 = Core.getfield(%64, 2))
â”‚   %67  = @_6::ANY
â”‚   %68  = Base.indexed_iterate(%59, 3, %67)::ANY
â”‚          (s13 = Core.getfield(%68, 1))
â”‚   %70  = Main.:/::Core.Const(/)
â”‚   %71  = Main.:+::Core.Const(+)
â”‚   %72  = s11::ANY
â”‚   %73  = s22::ANY
â”‚   %74  = s33::ANY
â”‚   %75  = (%71)(%72, %73, %74)::ANY
â”‚          (p = (%70)(%75, 3))
â”‚   %77  = Main.:-::Core.Const(-)
â”‚   %78  = s11::ANY
â”‚   %79  = p::ANY
â”‚   %80  = (%77)(%78, %79)::ANY
â”‚   %81  = Main.:-::Core.Const(-)
â”‚   %82  = s22::ANY
â”‚   %83  = p::ANY
â”‚   %84  = (%81)(%82, %83)::ANY
â”‚   %85  = Main.:-::Core.Const(-)
â”‚   %86  = s33::ANY
â”‚   %87  = p::ANY
â”‚   %88  = (%85)(%86, %87)::ANY
â”‚   %89  = s12::ANY
â”‚   %90  = s23::ANY
â”‚   %91  = s13::ANY
â”‚          (dev_vec = Base.vect(%80, %84, %88, %89, %90, %91))
â”‚   %93  = Main.:âˆš::Core.Const(sqrt)
â”‚   %94  = Main.:*::Core.Const(*)
â”‚   %95  = Main.:/::Core.Const(/)
â”‚   %96  = (%95)(3, 2)::Core.Const(1.5)
â”‚   %97  = Main.:+::Core.Const(+)
â”‚   %98  = Main.:^::Core.Const(^)
â”‚   %99  = dev_vec::ANY
â”‚   %100 = Base.getindex(%99, 1)::ANY
â”‚   %101 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
â”‚   %102 = (%101)()::Core.Const(Val{2}())
â”‚   %103 = Base.literal_pow(%98, %100, %102)::ANY
â”‚   %104 = Main.:^::Core.Const(^)
â”‚   %105 = dev_vec::ANY
â”‚   %106 = Base.getindex(%105, 2)::ANY
â”‚   %107 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
â”‚   %108 = (%107)()::Core.Const(Val{2}())
â”‚   %109 = Base.literal_pow(%104, %106, %108)::ANY
â”‚   %110 = Main.:^::Core.Const(^)
â”‚   %111 = dev_vec::ANY
â”‚   %112 = Base.getindex(%111, 3)::ANY
â”‚   %113 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
â”‚   %114 = (%113)()::Core.Const(Val{2}())
â”‚   %115 = Base.literal_pow(%110, %112, %114)::ANY
â”‚   %116 = Main.:*::Core.Const(*)
â”‚   %117 = Main.:+::Core.Const(+)
â”‚   %118 = Main.:^::Core.Const(^)
â”‚   %119 = dev_vec::ANY
â”‚   %120 = Base.getindex(%119, 4)::ANY
â”‚   %121 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
â”‚   %122 = (%121)()::Core.Const(Val{2}())
â”‚   %123 = Base.literal_pow(%118, %120, %122)::ANY
â”‚   %124 = Main.:^::Core.Const(^)
â”‚   %125 = dev_vec::ANY
â”‚   %126 = Base.getindex(%125, 5)::ANY
â”‚   %127 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
â”‚   %128 = (%127)()::Core.Const(Val{2}())
â”‚   %129 = Base.literal_pow(%124, %126, %128)::ANY
â”‚   %130 = Main.:^::Core.Const(^)
â”‚   %131 = dev_vec::ANY
â”‚   %132 = Base.getindex(%131, 6)::ANY
â”‚   %133 = Core.apply_type(Base.Val, 2)::Core.Const(Val{2})
â”‚   %134 = (%133)()::Core.Const(Val{2}())
â”‚   %135 = Base.literal_pow(%130, %132, %134)::ANY
â”‚   %136 = (%117)(%123, %129, %135)::ANY
â”‚   %137 = (%116)(2, %136)::ANY
â”‚   %138 = (%97)(%103, %109, %115, %137)::ANY
â”‚   %139 = (%94)(%96, %138)::ANY
â”‚          (Ïƒ_eq = (%93)(%139))
â”‚   %141 = Main.:-::Core.Const(-)
â”‚   %142 = Ïƒ_eq::ANY
â”‚   %143 = Base.getproperty(material, :Ïƒ_y)::Float64
â”‚          (f = (%141)(%142, %143))
â”‚   %145 = Main.copy::Core.Const(copy)
â”‚          (state_new = (%145)(state_old))
â”‚   %147 = Main.:>::Core.Const(>)
â”‚   %148 = f::ANY
â”‚   %149 = (%147)(%148, 0.0)::ANY
â””â”€â”€        goto #6 if not %149
5 â”€ %151 = Main.:/::Core.Const(/)
â”‚   %152 = Base.getproperty(material, :Ïƒ_y)::Float64
â”‚   %153 = Ïƒ_eq::ANY
â”‚          (factor = (%151)(%152, %153))
â”‚   %155 = Main.:+::Core.Const(+)
â”‚   %156 = p::ANY
â”‚   %157 = p::ANY
â”‚   %158 = p::ANY
â”‚   %159 = Base.vect(%156, %157, %158, 0.0, 0.0, 0.0)::ANY
â”‚   %160 = Main.:*::Core.Const(*)
â”‚   %161 = factor::ANY
â”‚   %162 = dev_vec::ANY
â”‚   %163 = (%160)(%161, %162)::ANY
â”‚          (Ïƒ_vec = (%155)(%159, %163))
â”‚   %165 = Main.:/::Core.Const(/)
â”‚   %166 = f::ANY
â”‚   %167 = Main.:/::Core.Const(/)
â”‚   %168 = Main.:*::Core.Const(*)
â”‚   %169 = Base.getproperty(material, :E)::Float64
â”‚   %170 = (%168)(3, %169)::Float64
â”‚   %171 = Main.:*::Core.Const(*)
â”‚   %172 = Main.:+::Core.Const(+)
â”‚   %173 = Base.getproperty(material, :Î½)::Float64
â”‚   %174 = (%172)(1, %173)::Float64
â”‚   %175 = (%171)(2, %174)::Float64
â”‚   %176 = (%167)(%170, %175)::Float64
â”‚          (Î”Î³ = (%165)(%166, %176))
â”‚   %178 = Main.:/::Core.Const(/)
â”‚   %179 = Main.:*::Core.Const(*)
â”‚   %180 = Main.:âˆš::Core.Const(sqrt)
â”‚   %181 = Main.:/::Core.Const(/)
â”‚   %182 = (%181)(3, 2)::Core.Const(1.5)
â”‚   %183 = (%180)(%182)::Core.Const(1.224744871391589)
â”‚   %184 = dev_vec::ANY
â”‚   %185 = (%179)(%183, %184)::ANY
â”‚   %186 = Ïƒ_eq::ANY
â”‚          (n_vec = (%178)(%185, %186))
â”‚   %188 = Main.:+::Core.Const(+)
â”‚   %189 = Îµ_p_vec::ANY
â”‚   %190 = Main.:*::Core.Const(*)
â”‚   %191 = Î”Î³::ANY
â”‚   %192 = n_vec::ANY
â”‚   %193 = (%190)(%191, %192)::ANY
â”‚   %194 = (%188)(%189, %193)::ANY
â”‚   %195 = state_new::Dict{String, Any}
â”‚          Base.setindex!(%195, %194, "epsilon_plastic")
â””â”€â”€        goto #7
6 â”€ %198 = Ïƒ_trial_vec::ANY
â””â”€â”€        (Ïƒ_vec = %198)
7 â”„ %200 = Ïƒ_vec::ANY
â”‚   %201 = D::Matrix{Float64}
â”‚   %202 = state_new::Dict{String, Any}
â”‚   %203 = Core.tuple(%200, %201, %202)::TUPLE{ANY, MATRIX{FLOAT64}, DICT{STRING, ANY}}
â””â”€â”€        return %203


================================================================================
ALLOCATION TESTS
================================================================================

Testing for allocations (should be 0 for new approach)...

1. Linear Elastic
   NEW (Tensors.jl):
     Allocations: 0 bytes
   OLD (Voigt/Dict):
     Allocations: 496 bytes

2. Neo-Hookean
   NEW (Tensors.jl + AD):
     Allocations: 0 bytes
   NEW (Tensors.jl + Manual):
     Allocations: 0 bytes
   OLD (Array):
     Allocations: 496 bytes

3. Perfect Plasticity (elastic branch)
   NEW (Tensors.jl):
     Allocations: 0 bytes
   OLD (Dict):
     Allocations: 8828848 bytes

================================================================================
PERFORMANCE BENCHMARKS
================================================================================

Running detailed benchmarks (this may take a minute)...

1. LINEAR ELASTIC
----------------------------------------
NEW (Tensors.jl):
BenchmarkTools.Trial: 10000 samples with 997 evaluations per sample.
 Range (min â€¦ max):  19.464 ns â€¦ 45.831 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     19.577 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   19.670 ns Â±  0.675 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–â–ˆâ–„                                                          
  â–ˆâ–ˆâ–ˆâ–‡â–„â–ƒâ–‚â–‚â–‚â–‚â–‚â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–‚â–â–â–â–‚â–â–â–â–‚â–‚â–â–â–â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  19.5 ns         Histogram: frequency by time        22.8 ns <

 Memory estimate: 0 bytes, allocs estimate: 0.

OLD (Voigt/Dict):
BenchmarkTools.Trial: 10000 samples with 950 evaluations per sample.
 Range (min â€¦ max):   93.356 ns â€¦   8.107 Î¼s  â”Š GC (min â€¦ max):  0.00% â€¦ 97.34%
 Time  (median):     100.107 ns               â”Š GC (median):     0.00%
 Time  (mean Â± Ïƒ):   139.733 ns Â± 249.840 ns  â”Š GC (mean Â± Ïƒ):  25.28% Â± 13.73%

  â–ˆâ–‚  â–                                                         â–
  â–ˆâ–ˆâ–„â–„â–ˆâ–ˆâ–â–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–†â–‡â–‡â–„â–ƒâ–„â–…â–„â–„â–…â–…â–…â–…â–…â–ƒâ–† â–ˆ
  93.4 ns       Histogram: log(frequency) by time       1.74 Î¼s <

 Memory estimate: 496 bytes, allocs estimate: 4.

SPEEDUP: 5.1Ã—

2. NEO-HOOKEAN
----------------------------------------
NEW (Tensors.jl + Automatic Differentiation):
BenchmarkTools.Trial: 10000 samples with 23 evaluations per sample.
 Range (min â€¦ max):  1.050 Î¼s â€¦  2.802 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     1.051 Î¼s              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.055 Î¼s Â± 31.780 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–ˆ                                                           
  â–ˆâ–„â–‚â–‚â–â–‚â–â–‚â–‚â–â–â–â–â–â–â–â–â–â–‚â–â–â–‚â–â–â–â–â–â–â–â–â–â–â–â–‚â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚ â–‚
  1.05 Î¼s        Histogram: frequency by time        1.19 Î¼s <

 Memory estimate: 0 bytes, allocs estimate: 0.

NEW (Tensors.jl + Manual Derivatives):
BenchmarkTools.Trial: 10000 samples with 987 evaluations per sample.
 Range (min â€¦ max):  49.806 ns â€¦  1.787 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     49.922 ns              â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   50.262 ns Â± 17.399 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

  â–…â–ˆâ–ˆâ–„â–                                                       â–‚
  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–†â–„â–â–„â–„â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–ƒâ–â–â–ƒâ–„â–„â–…â–…â–†â–†â–†â–†â–†â–‡â–‡â–ˆâ–‡â–‡â–‡â–‡â–‡â–ˆâ–ˆâ–‡â–‡â–†â–‡â–‡ â–ˆ
  49.8 ns      Histogram: log(frequency) by time      53.3 ns <

 Memory estimate: 0 bytes, allocs estimate: 0.

OLD (Array):
BenchmarkTools.Trial: 10000 samples with 955 evaluations per sample.
 Range (min â€¦ max):   91.182 ns â€¦   9.723 Î¼s  â”Š GC (min â€¦ max):  0.00% â€¦ 97.56%
 Time  (median):      99.922 ns               â”Š GC (median):     0.00%
 Time  (mean Â± Ïƒ):   142.795 ns Â± 307.090 ns  â”Š GC (mean Â± Ïƒ):  22.77% Â± 11.92%

  â–ˆâ–ƒ  â–„â–                                                        â–
  â–ˆâ–ˆâ–†â–„â–ˆâ–ˆâ–ƒâ–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–â–„â–‡â–ˆ â–ˆ
  91.2 ns       Histogram: log(frequency) by time       1.77 Î¼s <

 Memory estimate: 496 bytes, allocs estimate: 4.

SPEEDUP (AD):     0.1Ã—
SPEEDUP (Manual): 2.0Ã—
AD OVERHEAD:      21.1Ã— (AD / Manual)

3. PERFECT PLASTICITY (elastic branch)
----------------------------------------
NEW (Tensors.jl):
BenchmarkTools.Trial: 10000 samples with 976 evaluations per sample.
 Range (min â€¦ max):  69.677 ns â€¦ 151.814 ns  â”Š GC (min â€¦ max): 0.00% â€¦ 0.00%
 Time  (median):     70.389 ns               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   70.566 ns Â±   1.326 ns  â”Š GC (mean Â± Ïƒ):  0.00% Â± 0.00%

   â–‚â–†â–‡â–†â–‡â–†â–‡â–‡â–‡â–ˆâ–‡â–†â–‡â–†â–…â–ƒ                            â–â–â–â–â–â–â–‚â–â–â–â–â–    â–ƒ
  â–†â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‡â–‡â–‡â–†â–‡â–†â–†â–„â–ƒâ–â–â–â–â–â–†â–…â–…â–†â–‡â–†â–‡â–‡â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ â–ˆ
  69.7 ns       Histogram: log(frequency) by time      73.9 ns <

 Memory estimate: 0 bytes, allocs estimate: 0.

OLD (Dict):
BenchmarkTools.Trial: 10000 samples with 10 evaluations per sample.
 Range (min â€¦ max):  1.371 Î¼s â€¦ 998.345 Î¼s  â”Š GC (min â€¦ max): 0.00% â€¦ 99.45%
 Time  (median):     1.480 Î¼s               â”Š GC (median):    0.00%
 Time  (mean Â± Ïƒ):   1.701 Î¼s Â±   9.970 Î¼s  â”Š GC (mean Â± Ïƒ):  5.84% Â±  0.99%

      â–…â–ˆâ–†â–‚                                                     
  â–â–‚â–ƒâ–†â–ˆâ–ˆâ–ˆâ–ˆâ–†â–…â–„â–ƒâ–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–â–â–‚â–â–â–â–â–â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–ƒâ–ƒâ–ƒâ–ƒâ–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–â–â–â–â–â–â– â–‚
  1.37 Î¼s         Histogram: frequency by time        2.16 Î¼s <

 Memory estimate: 1.98 KiB, allocs estimate: 53.

SPEEDUP: 21.0Ã—

================================================================================
SUMMARY
================================================================================

ALLOCATIONS:
  LinearElastic:      NEW = 0 bytes, OLD = 496 bytes
  NeoHookean (AD):    NEW = 0 bytes, OLD = 496 bytes
  NeoHookean (Manual): NEW = 0 bytes
  PerfectPlasticity:  NEW = 0 bytes, OLD = 8828848 bytes

MEDIAN TIMING:
  LinearElastic:      NEW = 19.576730190571716 ns, OLD = 100.10684210526315 ns
  NeoHookean (AD):    NEW = 1051.304347826087 ns, OLD = 99.92198952879582 ns
  NeoHookean (Manual): NEW = 49.92198581560284 ns
  PerfectPlasticity:  NEW = 70.38934426229508 ns, OLD = 1479.55 ns

SPEEDUP (OLD / NEW):
  LinearElastic:      5.1Ã—
  NeoHookean (AD):    0.1Ã—
  NeoHookean (Manual): 2.0Ã—
  PerfectPlasticity:  21.0Ã—

AD OVERHEAD:
  NeoHookean: AD is 21.1Ã— slower than manual derivatives

AVERAGE SPEEDUP: 9.4Ã— (using manual Neo-Hookean)

VALIDATION OF CLAIMS:
  - Zero allocations for new approach: âœ“ PASS
  - Manual derivatives outperform AD: âœ“ PASS
  - Type stability with NoState return: Check @code_warntype output above

================================================================================
Benchmark complete! Results saved to: material_models_benchmark_results.txt
================================================================================
