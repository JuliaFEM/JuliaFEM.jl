# This file is a part of JuliaFEM.
# License is MIT: see https://github.com/JuliaFEM/JuliaFEM.jl/blob/master/LICENSE

# ============================================================================
# AUTO-GENERATED LAGRANGE BASIS FUNCTIONS
# ============================================================================
#
# WARNING: DO NOT EDIT THIS FILE MANUALLY!
#
# This file was automatically generated by:
#   julia --project=. src/basis/lagrange_generator.jl
#
# To regenerate (e.g., after adding new element types):
#   cd /path/to/JuliaFEM.jl
#   julia --project=. src/basis/lagrange_generator.jl
#
# Theory:
#   See docs/book/lagrange_basis_functions.md
#
# Generator:
#   src/basis/lagrange_generator.jl (symbolic engine)
#
# Generated: 2025-11-09 07:28:58
# ============================================================================

# Export all basis types
export Seg2Basis, Seg3Basis, Tri3Basis, Tri6Basis, Quad4Basis, Quad8Basis, Quad9Basis, Tet4Basis, Tet10Basis, Hex8Basis, Hex20Basis, Hex27Basis, Pyr5Basis, Wedge6Basis, Wedge15Basis

# ──────────────────────────────────────────────────────────────────────────────
# Seg2: 2-node linear segment element
# ──────────────────────────────────────────────────────────────────────────────

    struct Seg2Basis <: AbstractBasis{1}
            end
         Base.@pure function Base.size(::Type{Seg2Basis})
                                    return (1, 2)
        end
        function Base.size(::Type{Seg2Basis}, j::Int)
                        j == 1 && return 1
                j == 2 && return 2
    end
         Base.@pure function Base.length(::Type{Seg2Basis})
                                    return 2
        end
        function get_reference_element_coordinates(::Type{Seg2Basis})
                        return Vec{1, Float64}[[-1.0], [1.0]]
    end
         @inline function eval_basis!(::Type{Seg2Basis}, ::Type{T}, xi::Vec) where T
                                    (u,) = xi
                         @inbounds return (0.5 + -0.5u, 0.5 + 0.5u)
        end
         @inline function eval_dbasis!(::Type{Seg2Basis}, xi::Vec)
                                    (u,) = xi
                         @inbounds return (Vec(float.(tuple(-0.5))), Vec(float.(tuple(0.5))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Seg3: 3-node quadratic segment element
# ──────────────────────────────────────────────────────────────────────────────

    struct Seg3Basis <: AbstractBasis{1}
            end
         Base.@pure function Base.size(::Type{Seg3Basis})
                                    return (1, 3)
        end
        function Base.size(::Type{Seg3Basis}, j::Int)
                        j == 1 && return 1
                j == 2 && return 3
    end
         Base.@pure function Base.length(::Type{Seg3Basis})
                                    return 3
        end
        function get_reference_element_coordinates(::Type{Seg3Basis})
                        return Vec{1, Float64}[[-1.0], [1.0], [0.0]]
    end
         @inline function eval_basis!(::Type{Seg3Basis}, ::Type{T}, xi::Vec) where T
                                    (u,) = xi
                         @inbounds return (-0.5u + 0.5 * u ^ 2, 0.5u + 0.5 * u ^ 2, 1 + -1.0 * u ^ 2)
        end
         @inline function eval_dbasis!(::Type{Seg3Basis}, xi::Vec)
                                    (u,) = xi
                         @inbounds return (Vec(float.(tuple(-0.5 + 0.5 * (2 * u ^ (2 - 1))))), Vec(float.(tuple(0.5 + 0.5 * (2 * u ^ (2 - 1))))), Vec(float.(tuple(-1.0 * (2 * u ^ (2 - 1))))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Tri3: 3-node linear triangular element
# ──────────────────────────────────────────────────────────────────────────────

    struct Tri3Basis <: AbstractBasis{2}
            end
         Base.@pure function Base.size(::Type{Tri3Basis})
                                    return (2, 3)
        end
        function Base.size(::Type{Tri3Basis}, j::Int)
                        j == 1 && return 2
                j == 2 && return 3
    end
         Base.@pure function Base.length(::Type{Tri3Basis})
                                    return 3
        end
        function get_reference_element_coordinates(::Type{Tri3Basis})
                        return Vec{2, Float64}[[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]]
    end
         @inline function eval_basis!(::Type{Tri3Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v) = xi
                         @inbounds return (1 + -1.0u + -1.0v, +u, +v)
        end
         @inline function eval_dbasis!(::Type{Tri3Basis}, xi::Vec)
                                    (u, v) = xi
                         @inbounds return (Vec(float.(tuple(-1.0, -1.0))), Vec(float.(tuple(1, 0))), Vec(float.(tuple(0, 1))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Tri6: 6-node quadratic triangular element
# ──────────────────────────────────────────────────────────────────────────────

    struct Tri6Basis <: AbstractBasis{2}
            end
         Base.@pure function Base.size(::Type{Tri6Basis})
                                    return (2, 6)
        end
        function Base.size(::Type{Tri6Basis}, j::Int)
                        j == 1 && return 2
                j == 2 && return 6
    end
         Base.@pure function Base.length(::Type{Tri6Basis})
                                    return 6
        end
        function get_reference_element_coordinates(::Type{Tri6Basis})
                        return Vec{2, Float64}[[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [0.5, 0.0], [0.5, 0.5], [0.0, 0.5]]
    end
         @inline function eval_basis!(::Type{Tri6Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v) = xi
                         @inbounds return (1 + -3.0u + -3.0v + 2.0 * u ^ 2 + 4.0 * (u * v) + 2.0 * v ^ 2, -1.0u + 2.0 * u ^ 2, -1.0v + 2.0 * v ^ 2, 4.0u + -4.0 * u ^ 2 + -4.0 * (u * v), +(4.0 * (u * v)), 4.0v + -4.0 * (u * v) + -4.0 * v ^ 2)
        end
         @inline function eval_dbasis!(::Type{Tri6Basis}, xi::Vec)
                                    (u, v) = xi
                         @inbounds return (Vec(float.(tuple(-3.0 + 2.0 * (2 * u ^ (2 - 1)) + 4.0v, -3.0 + 4.0u + 2.0 * (2 * v ^ (2 - 1))))), Vec(float.(tuple(-1.0 + 2.0 * (2 * u ^ (2 - 1)), 0))), Vec(float.(tuple(0, -1.0 + 2.0 * (2 * v ^ (2 - 1))))), Vec(float.(tuple(4.0 + -4.0 * (2 * u ^ (2 - 1)) + -4.0v, -4.0u))), Vec(float.(tuple(4.0v, 4.0u))), Vec(float.(tuple(-4.0v, 4.0 + -4.0u + -4.0 * (2 * v ^ (2 - 1))))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Quad4: 4-node bilinear quadrilateral element
# ──────────────────────────────────────────────────────────────────────────────

    struct Quad4Basis <: AbstractBasis{2}
            end
         Base.@pure function Base.size(::Type{Quad4Basis})
                                    return (2, 4)
        end
        function Base.size(::Type{Quad4Basis}, j::Int)
                        j == 1 && return 2
                j == 2 && return 4
    end
         Base.@pure function Base.length(::Type{Quad4Basis})
                                    return 4
        end
        function get_reference_element_coordinates(::Type{Quad4Basis})
                        return Vec{2, Float64}[[-1.0, -1.0], [1.0, -1.0], [1.0, 1.0], [-1.0, 1.0]]
    end
         @inline function eval_basis!(::Type{Quad4Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v) = xi
                         @inbounds return (0.25 + -0.25u + -0.25v + 0.25 * (u * v), 0.25 + 0.25u + -0.25v + -0.25 * (u * v), 0.25 + 0.25u + 0.25v + 0.25 * (u * v), 0.25 + -0.25u + 0.25v + -0.25 * (u * v))
        end
         @inline function eval_dbasis!(::Type{Quad4Basis}, xi::Vec)
                                    (u, v) = xi
                         @inbounds return (Vec(float.(tuple(-0.25 + 0.25v, -0.25 + 0.25u))), Vec(float.(tuple(0.25 + -0.25v, -0.25 + -0.25u))), Vec(float.(tuple(0.25 + 0.25v, 0.25 + 0.25u))), Vec(float.(tuple(-0.25 + -0.25v, 0.25 + -0.25u))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Quad8: 8-node serendipity quadrilateral element
# ──────────────────────────────────────────────────────────────────────────────

    struct Quad8Basis <: AbstractBasis{2}
            end
         Base.@pure function Base.size(::Type{Quad8Basis})
                                    return (2, 8)
        end
        function Base.size(::Type{Quad8Basis}, j::Int)
                        j == 1 && return 2
                j == 2 && return 8
    end
         Base.@pure function Base.length(::Type{Quad8Basis})
                                    return 8
        end
        function get_reference_element_coordinates(::Type{Quad8Basis})
                        return Vec{2, Float64}[[-1.0, -1.0], [1.0, -1.0], [1.0, 1.0], [-1.0, 1.0], [0.0, -1.0], [1.0, 0.0], [0.0, 1.0], [-1.0, 0.0]]
    end
         @inline function eval_basis!(::Type{Quad8Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v) = xi
                         @inbounds return (-0.25 + 0.25 * u ^ 2 + 0.25 * (u * v) + 0.25 * v ^ 2 + -0.25 * (u ^ 2 * v) + -0.25 * (u * v ^ 2), -0.25 + 0.25 * u ^ 2 + -0.25 * (u * v) + 0.25 * v ^ 2 + -0.25 * (u ^ 2 * v) + 0.25 * (u * v ^ 2), -0.25 + 0.25 * u ^ 2 + 0.25 * (u * v) + 0.25 * v ^ 2 + 0.25 * (u ^ 2 * v) + 0.25 * (u * v ^ 2), -0.25 + 0.25 * u ^ 2 + -0.25 * (u * v) + 0.25 * v ^ 2 + 0.25 * (u ^ 2 * v) + -0.25 * (u * v ^ 2), 0.5 + -0.5v + -0.5 * u ^ 2 + 0.5 * (u ^ 2 * v), 0.5 + 0.5u + -0.5 * v ^ 2 + -0.5 * (u * v ^ 2), 0.5 + 0.5v + -0.5 * u ^ 2 + -0.5 * (u ^ 2 * v), 0.5 + -0.5u + -0.5 * v ^ 2 + 0.5 * (u * v ^ 2))
        end
         @inline function eval_dbasis!(::Type{Quad8Basis}, xi::Vec)
                                    (u, v) = xi
                         @inbounds return (Vec(float.(tuple(0.25 * (2 * u ^ (2 - 1)) + 0.25v + -0.25 * ((2 * u ^ (2 - 1)) * v) + -0.25 * v ^ 2, 0.25u + 0.25 * (2 * v ^ (2 - 1)) + -0.25 * u ^ 2 + -0.25 * (u * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(0.25 * (2 * u ^ (2 - 1)) + -0.25v + -0.25 * ((2 * u ^ (2 - 1)) * v) + 0.25 * v ^ 2, -0.25u + 0.25 * (2 * v ^ (2 - 1)) + -0.25 * u ^ 2 + 0.25 * (u * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(0.25 * (2 * u ^ (2 - 1)) + 0.25v + 0.25 * ((2 * u ^ (2 - 1)) * v) + 0.25 * v ^ 2, 0.25u + 0.25 * (2 * v ^ (2 - 1)) + 0.25 * u ^ 2 + 0.25 * (u * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(0.25 * (2 * u ^ (2 - 1)) + -0.25v + 0.25 * ((2 * u ^ (2 - 1)) * v) + -0.25 * v ^ 2, -0.25u + 0.25 * (2 * v ^ (2 - 1)) + 0.25 * u ^ 2 + -0.25 * (u * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(-0.5 * (2 * u ^ (2 - 1)) + 0.5 * ((2 * u ^ (2 - 1)) * v), -0.5 + 0.5 * u ^ 2))), Vec(float.(tuple(0.5 + -0.5 * v ^ 2, -0.5 * (2 * v ^ (2 - 1)) + -0.5 * (u * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(-0.5 * (2 * u ^ (2 - 1)) + -0.5 * ((2 * u ^ (2 - 1)) * v), 0.5 + -0.5 * u ^ 2))), Vec(float.(tuple(-0.5 + 0.5 * v ^ 2, -0.5 * (2 * v ^ (2 - 1)) + 0.5 * (u * (2 * v ^ (2 - 1)))))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Quad9: 9-node biquadratic quadrilateral element
# ──────────────────────────────────────────────────────────────────────────────

    struct Quad9Basis <: AbstractBasis{2}
            end
         Base.@pure function Base.size(::Type{Quad9Basis})
                                    return (2, 9)
        end
        function Base.size(::Type{Quad9Basis}, j::Int)
                        j == 1 && return 2
                j == 2 && return 9
    end
         Base.@pure function Base.length(::Type{Quad9Basis})
                                    return 9
        end
        function get_reference_element_coordinates(::Type{Quad9Basis})
                        return Vec{2, Float64}[[-1.0, -1.0], [1.0, -1.0], [1.0, 1.0], [-1.0, 1.0], [0.0, -1.0], [1.0, 0.0], [0.0, 1.0], [-1.0, 0.0], [0.0, 0.0]]
    end
         @inline function eval_basis!(::Type{Quad9Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v) = xi
                         @inbounds return (0.25 * (u * v) + -0.25 * (u ^ 2 * v) + -0.25 * (u * v ^ 2) + 0.25 * (u ^ 2 * v ^ 2), -0.25 * (u * v) + -0.25 * (u ^ 2 * v) + 0.25 * (u * v ^ 2) + 0.25 * (u ^ 2 * v ^ 2), 0.25 * (u * v) + 0.25 * (u ^ 2 * v) + 0.25 * (u * v ^ 2) + 0.25 * (u ^ 2 * v ^ 2), -0.25 * (u * v) + 0.25 * (u ^ 2 * v) + -0.25 * (u * v ^ 2) + 0.25 * (u ^ 2 * v ^ 2), -0.5v + 0.5 * v ^ 2 + 0.5 * (u ^ 2 * v) + -0.5 * (u ^ 2 * v ^ 2), 0.5u + 0.5 * u ^ 2 + -0.5 * (u * v ^ 2) + -0.5 * (u ^ 2 * v ^ 2), 0.5v + 0.5 * v ^ 2 + -0.5 * (u ^ 2 * v) + -0.5 * (u ^ 2 * v ^ 2), -0.5u + 0.5 * u ^ 2 + 0.5 * (u * v ^ 2) + -0.5 * (u ^ 2 * v ^ 2), 1 + -1.0 * u ^ 2 + -1.0 * v ^ 2 + u ^ 2 * v ^ 2)
        end
         @inline function eval_dbasis!(::Type{Quad9Basis}, xi::Vec)
                                    (u, v) = xi
                         @inbounds return (Vec(float.(tuple(0.25v + -0.25 * ((2 * u ^ (2 - 1)) * v) + -0.25 * v ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2), 0.25u + -0.25 * u ^ 2 + -0.25 * (u * (2 * v ^ (2 - 1))) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(-0.25v + -0.25 * ((2 * u ^ (2 - 1)) * v) + 0.25 * v ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2), -0.25u + -0.25 * u ^ 2 + 0.25 * (u * (2 * v ^ (2 - 1))) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(0.25v + 0.25 * ((2 * u ^ (2 - 1)) * v) + 0.25 * v ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2), 0.25u + 0.25 * u ^ 2 + 0.25 * (u * (2 * v ^ (2 - 1))) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(-0.25v + 0.25 * ((2 * u ^ (2 - 1)) * v) + -0.25 * v ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2), -0.25u + 0.25 * u ^ 2 + -0.25 * (u * (2 * v ^ (2 - 1))) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(0.5 * ((2 * u ^ (2 - 1)) * v) + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2), -0.5 + 0.5 * (2 * v ^ (2 - 1)) + 0.5 * u ^ 2 + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(0.5 + 0.5 * (2 * u ^ (2 - 1)) + -0.5 * v ^ 2 + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2), -0.5 * (u * (2 * v ^ (2 - 1))) + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(-0.5 * ((2 * u ^ (2 - 1)) * v) + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2), 0.5 + 0.5 * (2 * v ^ (2 - 1)) + -0.5 * u ^ 2 + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(-0.5 + 0.5 * (2 * u ^ (2 - 1)) + 0.5 * v ^ 2 + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2), 0.5 * (u * (2 * v ^ (2 - 1))) + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1)))))), Vec(float.(tuple(-1.0 * (2 * u ^ (2 - 1)) + (2 * u ^ (2 - 1)) * v ^ 2, -1.0 * (2 * v ^ (2 - 1)) + u ^ 2 * (2 * v ^ (2 - 1))))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Tet4: 4-node linear tetrahedral element
# ──────────────────────────────────────────────────────────────────────────────

    struct Tet4Basis <: AbstractBasis{3}
            end
         Base.@pure function Base.size(::Type{Tet4Basis})
                                    return (3, 4)
        end
        function Base.size(::Type{Tet4Basis}, j::Int)
                        j == 1 && return 3
                j == 2 && return 4
    end
         Base.@pure function Base.length(::Type{Tet4Basis})
                                    return 4
        end
        function get_reference_element_coordinates(::Type{Tet4Basis})
                        return Vec{3, Float64}[[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
    end
         @inline function eval_basis!(::Type{Tet4Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v, w) = xi
                         @inbounds return (1 + -1.0u + -1.0v + -1.0w, +u, +v, +w)
        end
         @inline function eval_dbasis!(::Type{Tet4Basis}, xi::Vec)
                                    (u, v, w) = xi
                         @inbounds return (Vec(float.(tuple(-1.0, -1.0, -1.0))), Vec(float.(tuple(1, 0, 0))), Vec(float.(tuple(0, 1, 0))), Vec(float.(tuple(0, 0, 1))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Tet10: 10-node quadratic tetrahedral element
# ──────────────────────────────────────────────────────────────────────────────

    struct Tet10Basis <: AbstractBasis{3}
            end
         Base.@pure function Base.size(::Type{Tet10Basis})
                                    return (3, 10)
        end
        function Base.size(::Type{Tet10Basis}, j::Int)
                        j == 1 && return 3
                j == 2 && return 10
    end
         Base.@pure function Base.length(::Type{Tet10Basis})
                                    return 10
        end
        function get_reference_element_coordinates(::Type{Tet10Basis})
                        return Vec{3, Float64}[[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [0.5, 0.0, 0.0], [0.5, 0.5, 0.0], [0.0, 0.5, 0.0], [0.0, 0.0, 0.5], [0.5, 0.0, 0.5], [0.0, 0.5, 0.5]]
    end
         @inline function eval_basis!(::Type{Tet10Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v, w) = xi
                         @inbounds return (1 + -3.0u + -3.0v + -3.0w + 2.0 * u ^ 2 + 2.0 * v ^ 2 + 2.0 * w ^ 2 + 4.0 * (u * v) + 4.0 * (u * w) + 4.0 * (v * w), -1.0u + 2.0 * u ^ 2, -1.0v + 2.0 * v ^ 2, -1.0w + 2.0 * w ^ 2, 4.0u + -4.0 * u ^ 2 + -4.0 * (u * v) + -4.0 * (u * w), +(4.0 * (u * v)), 4.0v + -4.0 * v ^ 2 + -4.0 * (u * v) + -4.0 * (v * w), 4.0w + -4.0 * w ^ 2 + -4.0 * (u * w) + -4.0 * (v * w), +(4.0 * (u * w)), +(4.0 * (v * w)))
        end
         @inline function eval_dbasis!(::Type{Tet10Basis}, xi::Vec)
                                    (u, v, w) = xi
                         @inbounds return (Vec(float.(tuple(-3.0 + 2.0 * (2 * u ^ (2 - 1)) + 4.0v + 4.0w, -3.0 + 2.0 * (2 * v ^ (2 - 1)) + 4.0u + 4.0w, -3.0 + 2.0 * (2 * w ^ (2 - 1)) + 4.0u + 4.0v))), Vec(float.(tuple(-1.0 + 2.0 * (2 * u ^ (2 - 1)), 0, 0))), Vec(float.(tuple(0, -1.0 + 2.0 * (2 * v ^ (2 - 1)), 0))), Vec(float.(tuple(0, 0, -1.0 + 2.0 * (2 * w ^ (2 - 1))))), Vec(float.(tuple(4.0 + -4.0 * (2 * u ^ (2 - 1)) + -4.0v + -4.0w, -4.0u, -4.0u))), Vec(float.(tuple(4.0v, 4.0u, 0))), Vec(float.(tuple(-4.0v, 4.0 + -4.0 * (2 * v ^ (2 - 1)) + -4.0u + -4.0w, -4.0v))), Vec(float.(tuple(-4.0w, -4.0w, 4.0 + -4.0 * (2 * w ^ (2 - 1)) + -4.0u + -4.0v))), Vec(float.(tuple(4.0w, 0, 4.0u))), Vec(float.(tuple(0, 4.0w, 4.0v))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Hex8: 8-node trilinear hexahedral element
# ──────────────────────────────────────────────────────────────────────────────

    struct Hex8Basis <: AbstractBasis{3}
            end
         Base.@pure function Base.size(::Type{Hex8Basis})
                                    return (3, 8)
        end
        function Base.size(::Type{Hex8Basis}, j::Int)
                        j == 1 && return 3
                j == 2 && return 8
    end
         Base.@pure function Base.length(::Type{Hex8Basis})
                                    return 8
        end
        function get_reference_element_coordinates(::Type{Hex8Basis})
                        return Vec{3, Float64}[[-1.0, -1.0, -1.0], [1.0, -1.0, -1.0], [1.0, 1.0, -1.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, 1.0], [1.0, -1.0, 1.0], [1.0, 1.0, 1.0], [-1.0, 1.0, 1.0]]
    end
         @inline function eval_basis!(::Type{Hex8Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v, w) = xi
                         @inbounds return (0.125 + -0.125u + -0.125v + -0.125w + 0.125 * (u * v) + 0.125 * (u * w) + 0.125 * (v * w) + -0.125 * (u * v * w), 0.125 + 0.125u + -0.125v + -0.125w + -0.125 * (u * v) + -0.125 * (u * w) + 0.125 * (v * w) + 0.125 * (u * v * w), 0.125 + 0.125u + 0.125v + -0.125w + 0.125 * (u * v) + -0.125 * (u * w) + -0.125 * (v * w) + -0.125 * (u * v * w), 0.125 + -0.125u + 0.125v + -0.125w + -0.125 * (u * v) + 0.125 * (u * w) + -0.125 * (v * w) + 0.125 * (u * v * w), 0.125 + -0.125u + -0.125v + 0.125w + 0.125 * (u * v) + -0.125 * (u * w) + -0.125 * (v * w) + 0.125 * (u * v * w), 0.125 + 0.125u + -0.125v + 0.125w + -0.125 * (u * v) + 0.125 * (u * w) + -0.125 * (v * w) + -0.125 * (u * v * w), 0.125 + 0.125u + 0.125v + 0.125w + 0.125 * (u * v) + 0.125 * (u * w) + 0.125 * (v * w) + 0.125 * (u * v * w), 0.125 + -0.125u + 0.125v + 0.125w + -0.125 * (u * v) + -0.125 * (u * w) + 0.125 * (v * w) + -0.125 * (u * v * w))
        end
         @inline function eval_dbasis!(::Type{Hex8Basis}, xi::Vec)
                                    (u, v, w) = xi
                         @inbounds return (Vec(float.(tuple(-0.125 + 0.125v + 0.125w + -0.125 * (v * w), -0.125 + 0.125u + 0.125w + -0.125 * (u * w), -0.125 + 0.125u + 0.125v + -0.125 * (u * v)))), Vec(float.(tuple(0.125 + -0.125v + -0.125w + 0.125 * (v * w), -0.125 + -0.125u + 0.125w + 0.125 * (u * w), -0.125 + -0.125u + 0.125v + 0.125 * (u * v)))), Vec(float.(tuple(0.125 + 0.125v + -0.125w + -0.125 * (v * w), 0.125 + 0.125u + -0.125w + -0.125 * (u * w), -0.125 + -0.125u + -0.125v + -0.125 * (u * v)))), Vec(float.(tuple(-0.125 + -0.125v + 0.125w + 0.125 * (v * w), 0.125 + -0.125u + -0.125w + 0.125 * (u * w), -0.125 + 0.125u + -0.125v + 0.125 * (u * v)))), Vec(float.(tuple(-0.125 + 0.125v + -0.125w + 0.125 * (v * w), -0.125 + 0.125u + -0.125w + 0.125 * (u * w), 0.125 + -0.125u + -0.125v + 0.125 * (u * v)))), Vec(float.(tuple(0.125 + -0.125v + 0.125w + -0.125 * (v * w), -0.125 + -0.125u + -0.125w + -0.125 * (u * w), 0.125 + 0.125u + -0.125v + -0.125 * (u * v)))), Vec(float.(tuple(0.125 + 0.125v + 0.125w + 0.125 * (v * w), 0.125 + 0.125u + 0.125w + 0.125 * (u * w), 0.125 + 0.125u + 0.125v + 0.125 * (u * v)))), Vec(float.(tuple(-0.125 + -0.125v + -0.125w + -0.125 * (v * w), 0.125 + -0.125u + 0.125w + -0.125 * (u * w), 0.125 + -0.125u + 0.125v + -0.125 * (u * v)))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Hex20: 20-node serendipity hexahedral element
# ──────────────────────────────────────────────────────────────────────────────

    struct Hex20Basis <: AbstractBasis{3}
            end
         Base.@pure function Base.size(::Type{Hex20Basis})
                                    return (3, 20)
        end
        function Base.size(::Type{Hex20Basis}, j::Int)
                        j == 1 && return 3
                j == 2 && return 20
    end
         Base.@pure function Base.length(::Type{Hex20Basis})
                                    return 20
        end
        function get_reference_element_coordinates(::Type{Hex20Basis})
                        return Vec{3, Float64}[[-1.0, -1.0, -1.0], [1.0, -1.0, -1.0], [1.0, 1.0, -1.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, 1.0], [1.0, -1.0, 1.0], [1.0, 1.0, 1.0], [-1.0, 1.0, 1.0], [0.0, -1.0, -1.0], [1.0, 0.0, -1.0], [0.0, 1.0, -1.0], [-1.0, 0.0, -1.0], [-1.0, -1.0, 0.0], [1.0, -1.0, 0.0], [1.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, -1.0, 1.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0], [-1.0, 0.0, 1.0]]
    end
         @inline function eval_basis!(::Type{Hex20Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v, w) = xi
                         @inbounds return (-0.25 + 0.125u + 0.125v + 0.125w + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * w ^ 2 + -0.125 * (u ^ 2 * v) + -0.125 * (u ^ 2 * w) + -0.125 * (v ^ 2 * u) + -0.125 * (v ^ 2 * w) + -0.125 * (w ^ 2 * u) + -0.125 * (w ^ 2 * v) + -0.125 * (u * v * w) + 0.125 * (u ^ 2 * v * w) + 0.125 * (u * v ^ 2 * w) + 0.125 * (u * v * w ^ 2), -0.25 + -0.125u + 0.125v + 0.125w + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * w ^ 2 + -0.125 * (u ^ 2 * v) + -0.125 * (u ^ 2 * w) + 0.125 * (v ^ 2 * u) + -0.125 * (v ^ 2 * w) + 0.125 * (w ^ 2 * u) + -0.125 * (w ^ 2 * v) + 0.125 * (u * v * w) + 0.125 * (u ^ 2 * v * w) + -0.125 * (u * v ^ 2 * w) + -0.125 * (u * v * w ^ 2), -0.25 + -0.125u + -0.125v + 0.125w + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * w ^ 2 + 0.125 * (u ^ 2 * v) + -0.125 * (u ^ 2 * w) + 0.125 * (v ^ 2 * u) + -0.125 * (v ^ 2 * w) + 0.125 * (w ^ 2 * u) + 0.125 * (w ^ 2 * v) + -0.125 * (u * v * w) + -0.125 * (u ^ 2 * v * w) + -0.125 * (u * v ^ 2 * w) + 0.125 * (u * v * w ^ 2), -0.25 + 0.125u + -0.125v + 0.125w + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * w ^ 2 + 0.125 * (u ^ 2 * v) + -0.125 * (u ^ 2 * w) + -0.125 * (v ^ 2 * u) + -0.125 * (v ^ 2 * w) + -0.125 * (w ^ 2 * u) + 0.125 * (w ^ 2 * v) + 0.125 * (u * v * w) + -0.125 * (u ^ 2 * v * w) + 0.125 * (u * v ^ 2 * w) + -0.125 * (u * v * w ^ 2), -0.25 + 0.125u + 0.125v + -0.125w + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * w ^ 2 + -0.125 * (u ^ 2 * v) + 0.125 * (u ^ 2 * w) + -0.125 * (v ^ 2 * u) + 0.125 * (v ^ 2 * w) + -0.125 * (w ^ 2 * u) + -0.125 * (w ^ 2 * v) + 0.125 * (u * v * w) + -0.125 * (u ^ 2 * v * w) + -0.125 * (u * v ^ 2 * w) + 0.125 * (u * v * w ^ 2), -0.25 + -0.125u + 0.125v + -0.125w + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * w ^ 2 + -0.125 * (u ^ 2 * v) + 0.125 * (u ^ 2 * w) + 0.125 * (v ^ 2 * u) + 0.125 * (v ^ 2 * w) + 0.125 * (w ^ 2 * u) + -0.125 * (w ^ 2 * v) + -0.125 * (u * v * w) + -0.125 * (u ^ 2 * v * w) + 0.125 * (u * v ^ 2 * w) + -0.125 * (u * v * w ^ 2), -0.25 + -0.125u + -0.125v + -0.125w + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * w ^ 2 + 0.125 * (u ^ 2 * v) + 0.125 * (u ^ 2 * w) + 0.125 * (v ^ 2 * u) + 0.125 * (v ^ 2 * w) + 0.125 * (w ^ 2 * u) + 0.125 * (w ^ 2 * v) + 0.125 * (u * v * w) + 0.125 * (u ^ 2 * v * w) + 0.125 * (u * v ^ 2 * w) + 0.125 * (u * v * w ^ 2), -0.25 + 0.125u + -0.125v + -0.125w + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * w ^ 2 + 0.125 * (u ^ 2 * v) + 0.125 * (u ^ 2 * w) + -0.125 * (v ^ 2 * u) + 0.125 * (v ^ 2 * w) + -0.125 * (w ^ 2 * u) + 0.125 * (w ^ 2 * v) + -0.125 * (u * v * w) + 0.125 * (u ^ 2 * v * w) + -0.125 * (u * v ^ 2 * w) + -0.125 * (u * v * w ^ 2), 0.25 + -0.25v + -0.25w + -0.25 * u ^ 2 + 0.25 * (v * w) + 0.25 * (u ^ 2 * v) + 0.25 * (u ^ 2 * w) + -0.25 * (u ^ 2 * v * w), 0.25 + 0.25u + -0.25w + -0.25 * v ^ 2 + -0.25 * (u * w) + -0.25 * (v ^ 2 * u) + 0.25 * (v ^ 2 * w) + 0.25 * (u * v ^ 2 * w), 0.25 + 0.25v + -0.25w + -0.25 * u ^ 2 + -0.25 * (v * w) + -0.25 * (u ^ 2 * v) + 0.25 * (u ^ 2 * w) + 0.25 * (u ^ 2 * v * w), 0.25 + -0.25u + -0.25w + -0.25 * v ^ 2 + 0.25 * (u * w) + 0.25 * (v ^ 2 * u) + 0.25 * (v ^ 2 * w) + -0.25 * (u * v ^ 2 * w), 0.25 + -0.25u + -0.25v + -0.25 * w ^ 2 + 0.25 * (u * v) + 0.25 * (w ^ 2 * u) + 0.25 * (w ^ 2 * v) + -0.25 * (u * v * w ^ 2), 0.25 + 0.25u + -0.25v + -0.25 * w ^ 2 + -0.25 * (u * v) + -0.25 * (w ^ 2 * u) + 0.25 * (w ^ 2 * v) + 0.25 * (u * v * w ^ 2), 0.25 + 0.25u + 0.25v + -0.25 * w ^ 2 + 0.25 * (u * v) + -0.25 * (w ^ 2 * u) + -0.25 * (w ^ 2 * v) + -0.25 * (u * v * w ^ 2), 0.25 + -0.25u + 0.25v + -0.25 * w ^ 2 + -0.25 * (u * v) + 0.25 * (w ^ 2 * u) + -0.25 * (w ^ 2 * v) + 0.25 * (u * v * w ^ 2), 0.25 + -0.25v + 0.25w + -0.25 * u ^ 2 + -0.25 * (v * w) + 0.25 * (u ^ 2 * v) + -0.25 * (u ^ 2 * w) + 0.25 * (u ^ 2 * v * w), 0.25 + 0.25u + 0.25w + -0.25 * v ^ 2 + 0.25 * (u * w) + -0.25 * (v ^ 2 * u) + -0.25 * (v ^ 2 * w) + -0.25 * (u * v ^ 2 * w), 0.25 + 0.25v + 0.25w + -0.25 * u ^ 2 + 0.25 * (v * w) + -0.25 * (u ^ 2 * v) + -0.25 * (u ^ 2 * w) + -0.25 * (u ^ 2 * v * w), 0.25 + -0.25u + 0.25w + -0.25 * v ^ 2 + -0.25 * (u * w) + 0.25 * (v ^ 2 * u) + -0.25 * (v ^ 2 * w) + 0.25 * (u * v ^ 2 * w))
        end
         @inline function eval_dbasis!(::Type{Hex20Basis}, xi::Vec)
                                    (u, v, w) = xi
                         @inbounds return (Vec(float.(tuple(0.125 + 0.125 * (2 * u ^ (2 - 1)) + -0.125 * ((2 * u ^ (2 - 1)) * v) + -0.125 * ((2 * u ^ (2 - 1)) * w) + -0.125 * v ^ 2 + -0.125 * w ^ 2 + -0.125 * (v * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w) + 0.125 * (v ^ 2 * w) + 0.125 * (v * w ^ 2), 0.125 + 0.125 * (2 * v ^ (2 - 1)) + -0.125 * u ^ 2 + -0.125 * ((2 * v ^ (2 - 1)) * u) + -0.125 * ((2 * v ^ (2 - 1)) * w) + -0.125 * w ^ 2 + -0.125 * (u * w) + 0.125 * (u ^ 2 * w) + 0.125 * (u * (2 * v ^ (2 - 1)) * w) + 0.125 * (u * w ^ 2), 0.125 + 0.125 * (2 * w ^ (2 - 1)) + -0.125 * u ^ 2 + -0.125 * v ^ 2 + -0.125 * ((2 * w ^ (2 - 1)) * u) + -0.125 * ((2 * w ^ (2 - 1)) * v) + -0.125 * (u * v) + 0.125 * (u ^ 2 * v) + 0.125 * (u * v ^ 2) + 0.125 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.125 + 0.125 * (2 * u ^ (2 - 1)) + -0.125 * ((2 * u ^ (2 - 1)) * v) + -0.125 * ((2 * u ^ (2 - 1)) * w) + 0.125 * v ^ 2 + 0.125 * w ^ 2 + 0.125 * (v * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w) + -0.125 * (v ^ 2 * w) + -0.125 * (v * w ^ 2), 0.125 + 0.125 * (2 * v ^ (2 - 1)) + -0.125 * u ^ 2 + 0.125 * ((2 * v ^ (2 - 1)) * u) + -0.125 * ((2 * v ^ (2 - 1)) * w) + -0.125 * w ^ 2 + 0.125 * (u * w) + 0.125 * (u ^ 2 * w) + -0.125 * (u * (2 * v ^ (2 - 1)) * w) + -0.125 * (u * w ^ 2), 0.125 + 0.125 * (2 * w ^ (2 - 1)) + -0.125 * u ^ 2 + -0.125 * v ^ 2 + 0.125 * ((2 * w ^ (2 - 1)) * u) + -0.125 * ((2 * w ^ (2 - 1)) * v) + 0.125 * (u * v) + 0.125 * (u ^ 2 * v) + -0.125 * (u * v ^ 2) + -0.125 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.125 + 0.125 * (2 * u ^ (2 - 1)) + 0.125 * ((2 * u ^ (2 - 1)) * v) + -0.125 * ((2 * u ^ (2 - 1)) * w) + 0.125 * v ^ 2 + 0.125 * w ^ 2 + -0.125 * (v * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w) + -0.125 * (v ^ 2 * w) + 0.125 * (v * w ^ 2), -0.125 + 0.125 * (2 * v ^ (2 - 1)) + 0.125 * u ^ 2 + 0.125 * ((2 * v ^ (2 - 1)) * u) + -0.125 * ((2 * v ^ (2 - 1)) * w) + 0.125 * w ^ 2 + -0.125 * (u * w) + -0.125 * (u ^ 2 * w) + -0.125 * (u * (2 * v ^ (2 - 1)) * w) + 0.125 * (u * w ^ 2), 0.125 + 0.125 * (2 * w ^ (2 - 1)) + -0.125 * u ^ 2 + -0.125 * v ^ 2 + 0.125 * ((2 * w ^ (2 - 1)) * u) + 0.125 * ((2 * w ^ (2 - 1)) * v) + -0.125 * (u * v) + -0.125 * (u ^ 2 * v) + -0.125 * (u * v ^ 2) + 0.125 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.125 + 0.125 * (2 * u ^ (2 - 1)) + 0.125 * ((2 * u ^ (2 - 1)) * v) + -0.125 * ((2 * u ^ (2 - 1)) * w) + -0.125 * v ^ 2 + -0.125 * w ^ 2 + 0.125 * (v * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w) + 0.125 * (v ^ 2 * w) + -0.125 * (v * w ^ 2), -0.125 + 0.125 * (2 * v ^ (2 - 1)) + 0.125 * u ^ 2 + -0.125 * ((2 * v ^ (2 - 1)) * u) + -0.125 * ((2 * v ^ (2 - 1)) * w) + 0.125 * w ^ 2 + 0.125 * (u * w) + -0.125 * (u ^ 2 * w) + 0.125 * (u * (2 * v ^ (2 - 1)) * w) + -0.125 * (u * w ^ 2), 0.125 + 0.125 * (2 * w ^ (2 - 1)) + -0.125 * u ^ 2 + -0.125 * v ^ 2 + -0.125 * ((2 * w ^ (2 - 1)) * u) + 0.125 * ((2 * w ^ (2 - 1)) * v) + 0.125 * (u * v) + -0.125 * (u ^ 2 * v) + 0.125 * (u * v ^ 2) + -0.125 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.125 + 0.125 * (2 * u ^ (2 - 1)) + -0.125 * ((2 * u ^ (2 - 1)) * v) + 0.125 * ((2 * u ^ (2 - 1)) * w) + -0.125 * v ^ 2 + -0.125 * w ^ 2 + 0.125 * (v * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w) + -0.125 * (v ^ 2 * w) + 0.125 * (v * w ^ 2), 0.125 + 0.125 * (2 * v ^ (2 - 1)) + -0.125 * u ^ 2 + -0.125 * ((2 * v ^ (2 - 1)) * u) + 0.125 * ((2 * v ^ (2 - 1)) * w) + -0.125 * w ^ 2 + 0.125 * (u * w) + -0.125 * (u ^ 2 * w) + -0.125 * (u * (2 * v ^ (2 - 1)) * w) + 0.125 * (u * w ^ 2), -0.125 + 0.125 * (2 * w ^ (2 - 1)) + 0.125 * u ^ 2 + 0.125 * v ^ 2 + -0.125 * ((2 * w ^ (2 - 1)) * u) + -0.125 * ((2 * w ^ (2 - 1)) * v) + 0.125 * (u * v) + -0.125 * (u ^ 2 * v) + -0.125 * (u * v ^ 2) + 0.125 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.125 + 0.125 * (2 * u ^ (2 - 1)) + -0.125 * ((2 * u ^ (2 - 1)) * v) + 0.125 * ((2 * u ^ (2 - 1)) * w) + 0.125 * v ^ 2 + 0.125 * w ^ 2 + -0.125 * (v * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w) + 0.125 * (v ^ 2 * w) + -0.125 * (v * w ^ 2), 0.125 + 0.125 * (2 * v ^ (2 - 1)) + -0.125 * u ^ 2 + 0.125 * ((2 * v ^ (2 - 1)) * u) + 0.125 * ((2 * v ^ (2 - 1)) * w) + -0.125 * w ^ 2 + -0.125 * (u * w) + -0.125 * (u ^ 2 * w) + 0.125 * (u * (2 * v ^ (2 - 1)) * w) + -0.125 * (u * w ^ 2), -0.125 + 0.125 * (2 * w ^ (2 - 1)) + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * ((2 * w ^ (2 - 1)) * u) + -0.125 * ((2 * w ^ (2 - 1)) * v) + -0.125 * (u * v) + -0.125 * (u ^ 2 * v) + 0.125 * (u * v ^ 2) + -0.125 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.125 + 0.125 * (2 * u ^ (2 - 1)) + 0.125 * ((2 * u ^ (2 - 1)) * v) + 0.125 * ((2 * u ^ (2 - 1)) * w) + 0.125 * v ^ 2 + 0.125 * w ^ 2 + 0.125 * (v * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w) + 0.125 * (v ^ 2 * w) + 0.125 * (v * w ^ 2), -0.125 + 0.125 * (2 * v ^ (2 - 1)) + 0.125 * u ^ 2 + 0.125 * ((2 * v ^ (2 - 1)) * u) + 0.125 * ((2 * v ^ (2 - 1)) * w) + 0.125 * w ^ 2 + 0.125 * (u * w) + 0.125 * (u ^ 2 * w) + 0.125 * (u * (2 * v ^ (2 - 1)) * w) + 0.125 * (u * w ^ 2), -0.125 + 0.125 * (2 * w ^ (2 - 1)) + 0.125 * u ^ 2 + 0.125 * v ^ 2 + 0.125 * ((2 * w ^ (2 - 1)) * u) + 0.125 * ((2 * w ^ (2 - 1)) * v) + 0.125 * (u * v) + 0.125 * (u ^ 2 * v) + 0.125 * (u * v ^ 2) + 0.125 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.125 + 0.125 * (2 * u ^ (2 - 1)) + 0.125 * ((2 * u ^ (2 - 1)) * v) + 0.125 * ((2 * u ^ (2 - 1)) * w) + -0.125 * v ^ 2 + -0.125 * w ^ 2 + -0.125 * (v * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w) + -0.125 * (v ^ 2 * w) + -0.125 * (v * w ^ 2), -0.125 + 0.125 * (2 * v ^ (2 - 1)) + 0.125 * u ^ 2 + -0.125 * ((2 * v ^ (2 - 1)) * u) + 0.125 * ((2 * v ^ (2 - 1)) * w) + 0.125 * w ^ 2 + -0.125 * (u * w) + 0.125 * (u ^ 2 * w) + -0.125 * (u * (2 * v ^ (2 - 1)) * w) + -0.125 * (u * w ^ 2), -0.125 + 0.125 * (2 * w ^ (2 - 1)) + 0.125 * u ^ 2 + 0.125 * v ^ 2 + -0.125 * ((2 * w ^ (2 - 1)) * u) + 0.125 * ((2 * w ^ (2 - 1)) * v) + -0.125 * (u * v) + 0.125 * (u ^ 2 * v) + -0.125 * (u * v ^ 2) + -0.125 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25 * (2 * u ^ (2 - 1)) + 0.25 * ((2 * u ^ (2 - 1)) * v) + 0.25 * ((2 * u ^ (2 - 1)) * w) + -0.25 * ((2 * u ^ (2 - 1)) * v * w), -0.25 + 0.25w + 0.25 * u ^ 2 + -0.25 * (u ^ 2 * w), -0.25 + 0.25v + 0.25 * u ^ 2 + -0.25 * (u ^ 2 * v)))), Vec(float.(tuple(0.25 + -0.25w + -0.25 * v ^ 2 + 0.25 * (v ^ 2 * w), -0.25 * (2 * v ^ (2 - 1)) + -0.25 * ((2 * v ^ (2 - 1)) * u) + 0.25 * ((2 * v ^ (2 - 1)) * w) + 0.25 * (u * (2 * v ^ (2 - 1)) * w), -0.25 + -0.25u + 0.25 * v ^ 2 + 0.25 * (u * v ^ 2)))), Vec(float.(tuple(-0.25 * (2 * u ^ (2 - 1)) + -0.25 * ((2 * u ^ (2 - 1)) * v) + 0.25 * ((2 * u ^ (2 - 1)) * w) + 0.25 * ((2 * u ^ (2 - 1)) * v * w), 0.25 + -0.25w + -0.25 * u ^ 2 + 0.25 * (u ^ 2 * w), -0.25 + -0.25v + 0.25 * u ^ 2 + 0.25 * (u ^ 2 * v)))), Vec(float.(tuple(-0.25 + 0.25w + 0.25 * v ^ 2 + -0.25 * (v ^ 2 * w), -0.25 * (2 * v ^ (2 - 1)) + 0.25 * ((2 * v ^ (2 - 1)) * u) + 0.25 * ((2 * v ^ (2 - 1)) * w) + -0.25 * (u * (2 * v ^ (2 - 1)) * w), -0.25 + 0.25u + 0.25 * v ^ 2 + -0.25 * (u * v ^ 2)))), Vec(float.(tuple(-0.25 + 0.25v + 0.25 * w ^ 2 + -0.25 * (v * w ^ 2), -0.25 + 0.25u + 0.25 * w ^ 2 + -0.25 * (u * w ^ 2), -0.25 * (2 * w ^ (2 - 1)) + 0.25 * ((2 * w ^ (2 - 1)) * u) + 0.25 * ((2 * w ^ (2 - 1)) * v) + -0.25 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.25 + -0.25v + -0.25 * w ^ 2 + 0.25 * (v * w ^ 2), -0.25 + -0.25u + 0.25 * w ^ 2 + 0.25 * (u * w ^ 2), -0.25 * (2 * w ^ (2 - 1)) + -0.25 * ((2 * w ^ (2 - 1)) * u) + 0.25 * ((2 * w ^ (2 - 1)) * v) + 0.25 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.25 + 0.25v + -0.25 * w ^ 2 + -0.25 * (v * w ^ 2), 0.25 + 0.25u + -0.25 * w ^ 2 + -0.25 * (u * w ^ 2), -0.25 * (2 * w ^ (2 - 1)) + -0.25 * ((2 * w ^ (2 - 1)) * u) + -0.25 * ((2 * w ^ (2 - 1)) * v) + -0.25 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25 + -0.25v + 0.25 * w ^ 2 + 0.25 * (v * w ^ 2), 0.25 + -0.25u + -0.25 * w ^ 2 + 0.25 * (u * w ^ 2), -0.25 * (2 * w ^ (2 - 1)) + 0.25 * ((2 * w ^ (2 - 1)) * u) + -0.25 * ((2 * w ^ (2 - 1)) * v) + 0.25 * (u * v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25 * (2 * u ^ (2 - 1)) + 0.25 * ((2 * u ^ (2 - 1)) * v) + -0.25 * ((2 * u ^ (2 - 1)) * w) + 0.25 * ((2 * u ^ (2 - 1)) * v * w), -0.25 + -0.25w + 0.25 * u ^ 2 + 0.25 * (u ^ 2 * w), 0.25 + -0.25v + -0.25 * u ^ 2 + 0.25 * (u ^ 2 * v)))), Vec(float.(tuple(0.25 + 0.25w + -0.25 * v ^ 2 + -0.25 * (v ^ 2 * w), -0.25 * (2 * v ^ (2 - 1)) + -0.25 * ((2 * v ^ (2 - 1)) * u) + -0.25 * ((2 * v ^ (2 - 1)) * w) + -0.25 * (u * (2 * v ^ (2 - 1)) * w), 0.25 + 0.25u + -0.25 * v ^ 2 + -0.25 * (u * v ^ 2)))), Vec(float.(tuple(-0.25 * (2 * u ^ (2 - 1)) + -0.25 * ((2 * u ^ (2 - 1)) * v) + -0.25 * ((2 * u ^ (2 - 1)) * w) + -0.25 * ((2 * u ^ (2 - 1)) * v * w), 0.25 + 0.25w + -0.25 * u ^ 2 + -0.25 * (u ^ 2 * w), 0.25 + 0.25v + -0.25 * u ^ 2 + -0.25 * (u ^ 2 * v)))), Vec(float.(tuple(-0.25 + -0.25w + 0.25 * v ^ 2 + 0.25 * (v ^ 2 * w), -0.25 * (2 * v ^ (2 - 1)) + 0.25 * ((2 * v ^ (2 - 1)) * u) + -0.25 * ((2 * v ^ (2 - 1)) * w) + 0.25 * (u * (2 * v ^ (2 - 1)) * w), 0.25 + -0.25u + -0.25 * v ^ 2 + 0.25 * (u * v ^ 2)))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Hex27: 27-node triquadratic hexahedral element
# ──────────────────────────────────────────────────────────────────────────────

    struct Hex27Basis <: AbstractBasis{3}
            end
         Base.@pure function Base.size(::Type{Hex27Basis})
                                    return (3, 27)
        end
        function Base.size(::Type{Hex27Basis}, j::Int)
                        j == 1 && return 3
                j == 2 && return 27
    end
         Base.@pure function Base.length(::Type{Hex27Basis})
                                    return 27
        end
        function get_reference_element_coordinates(::Type{Hex27Basis})
                        return Vec{3, Float64}[[-1.0, -1.0, -1.0], [1.0, -1.0, -1.0], [1.0, 1.0, -1.0], [-1.0, 1.0, -1.0], [-1.0, -1.0, 1.0], [1.0, -1.0, 1.0], [1.0, 1.0, 1.0], [-1.0, 1.0, 1.0], [0.0, -1.0, -1.0], [1.0, 0.0, -1.0], [0.0, 1.0, -1.0], [-1.0, 0.0, -1.0], [-1.0, -1.0, 0.0], [1.0, -1.0, 0.0], [1.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, -1.0, 1.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0], [-1.0, 0.0, 1.0], [0.0, 0.0, -1.0], [0.0, 0.0, 1.0], [0.0, -1.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 0.0]]
    end
         @inline function eval_basis!(::Type{Hex27Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v, w) = xi
                         @inbounds return (-0.125 * (u * v * w) + 0.125 * (u ^ 2 * v * w) + 0.125 * (u * v ^ 2 * w) + 0.125 * (u * v * w ^ 2) + -0.125 * (u ^ 2 * v ^ 2 * w) + -0.125 * (u ^ 2 * v * w ^ 2) + -0.125 * (u * v ^ 2 * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w ^ 2), 0.125 * (u * v * w) + 0.125 * (u ^ 2 * v * w) + -0.125 * (u * v ^ 2 * w) + -0.125 * (u * v * w ^ 2) + -0.125 * (u ^ 2 * v ^ 2 * w) + -0.125 * (u ^ 2 * v * w ^ 2) + 0.125 * (u * v ^ 2 * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w ^ 2), -0.125 * (u * v * w) + -0.125 * (u ^ 2 * v * w) + -0.125 * (u * v ^ 2 * w) + 0.125 * (u * v * w ^ 2) + -0.125 * (u ^ 2 * v ^ 2 * w) + 0.125 * (u ^ 2 * v * w ^ 2) + 0.125 * (u * v ^ 2 * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w ^ 2), 0.125 * (u * v * w) + -0.125 * (u ^ 2 * v * w) + 0.125 * (u * v ^ 2 * w) + -0.125 * (u * v * w ^ 2) + -0.125 * (u ^ 2 * v ^ 2 * w) + 0.125 * (u ^ 2 * v * w ^ 2) + -0.125 * (u * v ^ 2 * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w ^ 2), 0.125 * (u * v * w) + -0.125 * (u ^ 2 * v * w) + -0.125 * (u * v ^ 2 * w) + 0.125 * (u * v * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w) + -0.125 * (u ^ 2 * v * w ^ 2) + -0.125 * (u * v ^ 2 * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w ^ 2), -0.125 * (u * v * w) + -0.125 * (u ^ 2 * v * w) + 0.125 * (u * v ^ 2 * w) + -0.125 * (u * v * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w) + -0.125 * (u ^ 2 * v * w ^ 2) + 0.125 * (u * v ^ 2 * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w ^ 2), 0.125 * (u * v * w) + 0.125 * (u ^ 2 * v * w) + 0.125 * (u * v ^ 2 * w) + 0.125 * (u * v * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w) + 0.125 * (u ^ 2 * v * w ^ 2) + 0.125 * (u * v ^ 2 * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w ^ 2), -0.125 * (u * v * w) + 0.125 * (u ^ 2 * v * w) + -0.125 * (u * v ^ 2 * w) + -0.125 * (u * v * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w) + 0.125 * (u ^ 2 * v * w ^ 2) + -0.125 * (u * v ^ 2 * w ^ 2) + 0.125 * (u ^ 2 * v ^ 2 * w ^ 2), 0.25 * (v * w) + -0.25 * (v ^ 2 * w) + -0.25 * (w ^ 2 * v) + 0.25 * (v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v * w) + 0.25 * (u ^ 2 * v ^ 2 * w) + 0.25 * (u ^ 2 * v * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), -0.25 * (u * w) + -0.25 * (u ^ 2 * w) + 0.25 * (w ^ 2 * u) + 0.25 * (u ^ 2 * w ^ 2) + 0.25 * (u * v ^ 2 * w) + 0.25 * (u ^ 2 * v ^ 2 * w) + -0.25 * (u * v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), -0.25 * (v * w) + -0.25 * (v ^ 2 * w) + 0.25 * (w ^ 2 * v) + 0.25 * (v ^ 2 * w ^ 2) + 0.25 * (u ^ 2 * v * w) + 0.25 * (u ^ 2 * v ^ 2 * w) + -0.25 * (u ^ 2 * v * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), 0.25 * (u * w) + -0.25 * (u ^ 2 * w) + -0.25 * (w ^ 2 * u) + 0.25 * (u ^ 2 * w ^ 2) + -0.25 * (u * v ^ 2 * w) + 0.25 * (u ^ 2 * v ^ 2 * w) + 0.25 * (u * v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), 0.25 * (u * v) + -0.25 * (u ^ 2 * v) + -0.25 * (v ^ 2 * u) + 0.25 * (u ^ 2 * v ^ 2) + -0.25 * (u * v * w ^ 2) + 0.25 * (u ^ 2 * v * w ^ 2) + 0.25 * (u * v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), -0.25 * (u * v) + -0.25 * (u ^ 2 * v) + 0.25 * (v ^ 2 * u) + 0.25 * (u ^ 2 * v ^ 2) + 0.25 * (u * v * w ^ 2) + 0.25 * (u ^ 2 * v * w ^ 2) + -0.25 * (u * v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), 0.25 * (u * v) + 0.25 * (u ^ 2 * v) + 0.25 * (v ^ 2 * u) + 0.25 * (u ^ 2 * v ^ 2) + -0.25 * (u * v * w ^ 2) + -0.25 * (u ^ 2 * v * w ^ 2) + -0.25 * (u * v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), -0.25 * (u * v) + 0.25 * (u ^ 2 * v) + -0.25 * (v ^ 2 * u) + 0.25 * (u ^ 2 * v ^ 2) + 0.25 * (u * v * w ^ 2) + -0.25 * (u ^ 2 * v * w ^ 2) + 0.25 * (u * v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), -0.25 * (v * w) + 0.25 * (v ^ 2 * w) + -0.25 * (w ^ 2 * v) + 0.25 * (v ^ 2 * w ^ 2) + 0.25 * (u ^ 2 * v * w) + -0.25 * (u ^ 2 * v ^ 2 * w) + 0.25 * (u ^ 2 * v * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), 0.25 * (u * w) + 0.25 * (u ^ 2 * w) + 0.25 * (w ^ 2 * u) + 0.25 * (u ^ 2 * w ^ 2) + -0.25 * (u * v ^ 2 * w) + -0.25 * (u ^ 2 * v ^ 2 * w) + -0.25 * (u * v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), 0.25 * (v * w) + 0.25 * (v ^ 2 * w) + 0.25 * (w ^ 2 * v) + 0.25 * (v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v * w) + -0.25 * (u ^ 2 * v ^ 2 * w) + -0.25 * (u ^ 2 * v * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), -0.25 * (u * w) + 0.25 * (u ^ 2 * w) + -0.25 * (w ^ 2 * u) + 0.25 * (u ^ 2 * w ^ 2) + 0.25 * (u * v ^ 2 * w) + -0.25 * (u ^ 2 * v ^ 2 * w) + 0.25 * (u * v ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * v ^ 2 * w ^ 2), -0.5w + 0.5 * w ^ 2 + 0.5 * (u ^ 2 * w) + 0.5 * (v ^ 2 * w) + -0.5 * (u ^ 2 * w ^ 2) + -0.5 * (v ^ 2 * w ^ 2) + -0.5 * (u ^ 2 * v ^ 2 * w) + 0.5 * (u ^ 2 * v ^ 2 * w ^ 2), 0.5w + 0.5 * w ^ 2 + -0.5 * (u ^ 2 * w) + -0.5 * (v ^ 2 * w) + -0.5 * (u ^ 2 * w ^ 2) + -0.5 * (v ^ 2 * w ^ 2) + 0.5 * (u ^ 2 * v ^ 2 * w) + 0.5 * (u ^ 2 * v ^ 2 * w ^ 2), -0.5v + 0.5 * v ^ 2 + 0.5 * (u ^ 2 * v) + 0.5 * (w ^ 2 * v) + -0.5 * (u ^ 2 * v ^ 2) + -0.5 * (v ^ 2 * w ^ 2) + -0.5 * (u ^ 2 * v * w ^ 2) + 0.5 * (u ^ 2 * v ^ 2 * w ^ 2), 0.5u + 0.5 * u ^ 2 + -0.5 * (v ^ 2 * u) + -0.5 * (w ^ 2 * u) + -0.5 * (u ^ 2 * v ^ 2) + -0.5 * (u ^ 2 * w ^ 2) + 0.5 * (u * v ^ 2 * w ^ 2) + 0.5 * (u ^ 2 * v ^ 2 * w ^ 2), 0.5v + 0.5 * v ^ 2 + -0.5 * (u ^ 2 * v) + -0.5 * (w ^ 2 * v) + -0.5 * (u ^ 2 * v ^ 2) + -0.5 * (v ^ 2 * w ^ 2) + 0.5 * (u ^ 2 * v * w ^ 2) + 0.5 * (u ^ 2 * v ^ 2 * w ^ 2), -0.5u + 0.5 * u ^ 2 + 0.5 * (v ^ 2 * u) + 0.5 * (w ^ 2 * u) + -0.5 * (u ^ 2 * v ^ 2) + -0.5 * (u ^ 2 * w ^ 2) + -0.5 * (u * v ^ 2 * w ^ 2) + 0.5 * (u ^ 2 * v ^ 2 * w ^ 2), 1 + -1.0 * u ^ 2 + -1.0 * v ^ 2 + -1.0 * w ^ 2 + u ^ 2 * v ^ 2 + u ^ 2 * w ^ 2 + v ^ 2 * w ^ 2 + -1.0 * (u ^ 2 * v ^ 2 * w ^ 2))
        end
         @inline function eval_dbasis!(::Type{Hex27Basis}, xi::Vec)
                                    (u, v, w) = xi
                         @inbounds return (Vec(float.(tuple(-0.125 * (v * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w) + 0.125 * (v ^ 2 * w) + 0.125 * (v * w ^ 2) + -0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.125 * (v ^ 2 * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.125 * (u * w) + 0.125 * (u ^ 2 * w) + 0.125 * (u * (2 * v ^ (2 - 1)) * w) + 0.125 * (u * w ^ 2) + -0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + -0.125 * (u ^ 2 * w ^ 2) + -0.125 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.125 * (u * v) + 0.125 * (u ^ 2 * v) + 0.125 * (u * v ^ 2) + 0.125 * (u * v * (2 * w ^ (2 - 1))) + -0.125 * (u ^ 2 * v ^ 2) + -0.125 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.125 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.125 * (v * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w) + -0.125 * (v ^ 2 * w) + -0.125 * (v * w ^ 2) + -0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + 0.125 * (v ^ 2 * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.125 * (u * w) + 0.125 * (u ^ 2 * w) + -0.125 * (u * (2 * v ^ (2 - 1)) * w) + -0.125 * (u * w ^ 2) + -0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + -0.125 * (u ^ 2 * w ^ 2) + 0.125 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.125 * (u * v) + 0.125 * (u ^ 2 * v) + -0.125 * (u * v ^ 2) + -0.125 * (u * v * (2 * w ^ (2 - 1))) + -0.125 * (u ^ 2 * v ^ 2) + -0.125 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + 0.125 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.125 * (v * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w) + -0.125 * (v ^ 2 * w) + 0.125 * (v * w ^ 2) + -0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + 0.125 * (v ^ 2 * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.125 * (u * w) + -0.125 * (u ^ 2 * w) + -0.125 * (u * (2 * v ^ (2 - 1)) * w) + 0.125 * (u * w ^ 2) + -0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.125 * (u ^ 2 * w ^ 2) + 0.125 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.125 * (u * v) + -0.125 * (u ^ 2 * v) + -0.125 * (u * v ^ 2) + 0.125 * (u * v * (2 * w ^ (2 - 1))) + -0.125 * (u ^ 2 * v ^ 2) + 0.125 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + 0.125 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.125 * (v * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w) + 0.125 * (v ^ 2 * w) + -0.125 * (v * w ^ 2) + -0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.125 * (v ^ 2 * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.125 * (u * w) + -0.125 * (u ^ 2 * w) + 0.125 * (u * (2 * v ^ (2 - 1)) * w) + -0.125 * (u * w ^ 2) + -0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.125 * (u ^ 2 * w ^ 2) + -0.125 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.125 * (u * v) + -0.125 * (u ^ 2 * v) + 0.125 * (u * v ^ 2) + -0.125 * (u * v * (2 * w ^ (2 - 1))) + -0.125 * (u ^ 2 * v ^ 2) + 0.125 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.125 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.125 * (v * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w) + -0.125 * (v ^ 2 * w) + 0.125 * (v * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.125 * (v ^ 2 * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.125 * (u * w) + -0.125 * (u ^ 2 * w) + -0.125 * (u * (2 * v ^ (2 - 1)) * w) + 0.125 * (u * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + -0.125 * (u ^ 2 * w ^ 2) + -0.125 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.125 * (u * v) + -0.125 * (u ^ 2 * v) + -0.125 * (u * v ^ 2) + 0.125 * (u * v * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2) + -0.125 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.125 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.125 * (v * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w) + 0.125 * (v ^ 2 * w) + -0.125 * (v * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + -0.125 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + 0.125 * (v ^ 2 * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.125 * (u * w) + -0.125 * (u ^ 2 * w) + 0.125 * (u * (2 * v ^ (2 - 1)) * w) + -0.125 * (u * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + -0.125 * (u ^ 2 * w ^ 2) + 0.125 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.125 * (u * v) + -0.125 * (u ^ 2 * v) + 0.125 * (u * v ^ 2) + -0.125 * (u * v * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2) + -0.125 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + 0.125 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.125 * (v * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w) + 0.125 * (v ^ 2 * w) + 0.125 * (v * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + 0.125 * (v ^ 2 * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.125 * (u * w) + 0.125 * (u ^ 2 * w) + 0.125 * (u * (2 * v ^ (2 - 1)) * w) + 0.125 * (u * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.125 * (u ^ 2 * w ^ 2) + 0.125 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.125 * (u * v) + 0.125 * (u ^ 2 * v) + 0.125 * (u * v ^ 2) + 0.125 * (u * v * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2) + 0.125 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + 0.125 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.125 * (v * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w) + -0.125 * (v ^ 2 * w) + -0.125 * (v * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.125 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.125 * (v ^ 2 * w ^ 2) + 0.125 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.125 * (u * w) + 0.125 * (u ^ 2 * w) + -0.125 * (u * (2 * v ^ (2 - 1)) * w) + -0.125 * (u * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.125 * (u ^ 2 * w ^ 2) + -0.125 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.125 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.125 * (u * v) + 0.125 * (u ^ 2 * v) + -0.125 * (u * v ^ 2) + -0.125 * (u * v * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2) + 0.125 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.125 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.125 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25 * ((2 * u ^ (2 - 1)) * v * w) + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.25 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.25w + -0.25 * ((2 * v ^ (2 - 1)) * w) + -0.25 * w ^ 2 + 0.25 * ((2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * w) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.25 * (u ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.25v + -0.25 * v ^ 2 + -0.25 * ((2 * w ^ (2 - 1)) * v) + 0.25 * (v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v) + 0.25 * (u ^ 2 * v ^ 2) + 0.25 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25w + -0.25 * ((2 * u ^ (2 - 1)) * w) + 0.25 * w ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * w ^ 2) + 0.25 * (v ^ 2 * w) + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + -0.25 * (v ^ 2 * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.25 * (u * (2 * v ^ (2 - 1)) * w) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + -0.25 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.25u + -0.25 * u ^ 2 + 0.25 * ((2 * w ^ (2 - 1)) * u) + 0.25 * (u ^ 2 * (2 * w ^ (2 - 1))) + 0.25 * (u * v ^ 2) + 0.25 * (u ^ 2 * v ^ 2) + -0.25 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.25 * ((2 * u ^ (2 - 1)) * v * w) + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + -0.25 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.25w + -0.25 * ((2 * v ^ (2 - 1)) * w) + 0.25 * w ^ 2 + 0.25 * ((2 * v ^ (2 - 1)) * w ^ 2) + 0.25 * (u ^ 2 * w) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + -0.25 * (u ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.25v + -0.25 * v ^ 2 + 0.25 * ((2 * w ^ (2 - 1)) * v) + 0.25 * (v ^ 2 * (2 * w ^ (2 - 1))) + 0.25 * (u ^ 2 * v) + 0.25 * (u ^ 2 * v ^ 2) + -0.25 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.25w + -0.25 * ((2 * u ^ (2 - 1)) * w) + -0.25 * w ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * w ^ 2) + -0.25 * (v ^ 2 * w) + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.25 * (v ^ 2 * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.25 * (u * (2 * v ^ (2 - 1)) * w) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.25 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.25u + -0.25 * u ^ 2 + -0.25 * ((2 * w ^ (2 - 1)) * u) + 0.25 * (u ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u * v ^ 2) + 0.25 * (u ^ 2 * v ^ 2) + 0.25 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.25v + -0.25 * ((2 * u ^ (2 - 1)) * v) + -0.25 * v ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2) + -0.25 * (v * w ^ 2) + 0.25 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + 0.25 * (v ^ 2 * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.25u + -0.25 * u ^ 2 + -0.25 * ((2 * v ^ (2 - 1)) * u) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1))) + -0.25 * (u * w ^ 2) + 0.25 * (u ^ 2 * w ^ 2) + 0.25 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.25 * (u * v * (2 * w ^ (2 - 1))) + 0.25 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + 0.25 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25v + -0.25 * ((2 * u ^ (2 - 1)) * v) + 0.25 * v ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2) + 0.25 * (v * w ^ 2) + 0.25 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.25 * (v ^ 2 * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.25u + -0.25 * u ^ 2 + 0.25 * ((2 * v ^ (2 - 1)) * u) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1))) + 0.25 * (u * w ^ 2) + 0.25 * (u ^ 2 * w ^ 2) + -0.25 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.25 * (u * v * (2 * w ^ (2 - 1))) + 0.25 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.25 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.25v + 0.25 * ((2 * u ^ (2 - 1)) * v) + 0.25 * v ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2) + -0.25 * (v * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.25 * (v ^ 2 * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.25u + 0.25 * u ^ 2 + 0.25 * ((2 * v ^ (2 - 1)) * u) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1))) + -0.25 * (u * w ^ 2) + -0.25 * (u ^ 2 * w ^ 2) + -0.25 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.25 * (u * v * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.25 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25v + 0.25 * ((2 * u ^ (2 - 1)) * v) + -0.25 * v ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * v ^ 2) + 0.25 * (v * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + 0.25 * (v ^ 2 * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.25u + 0.25 * u ^ 2 + -0.25 * ((2 * v ^ (2 - 1)) * u) + 0.25 * (u ^ 2 * (2 * v ^ (2 - 1))) + 0.25 * (u * w ^ 2) + -0.25 * (u ^ 2 * w ^ 2) + 0.25 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.25 * (u * v * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + 0.25 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.25 * ((2 * u ^ (2 - 1)) * v * w) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.25 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.25w + 0.25 * ((2 * v ^ (2 - 1)) * w) + -0.25 * w ^ 2 + 0.25 * ((2 * v ^ (2 - 1)) * w ^ 2) + 0.25 * (u ^ 2 * w) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.25 * (u ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.25v + 0.25 * v ^ 2 + -0.25 * ((2 * w ^ (2 - 1)) * v) + 0.25 * (v ^ 2 * (2 * w ^ (2 - 1))) + 0.25 * (u ^ 2 * v) + -0.25 * (u ^ 2 * v ^ 2) + 0.25 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.25w + 0.25 * ((2 * u ^ (2 - 1)) * w) + 0.25 * w ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * w ^ 2) + -0.25 * (v ^ 2 * w) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + -0.25 * (v ^ 2 * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.25 * (u * (2 * v ^ (2 - 1)) * w) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + -0.25 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.25u + 0.25 * u ^ 2 + 0.25 * ((2 * w ^ (2 - 1)) * u) + 0.25 * (u ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u * v ^ 2) + -0.25 * (u ^ 2 * v ^ 2) + -0.25 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25 * ((2 * u ^ (2 - 1)) * v * w) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + -0.25 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.25w + 0.25 * ((2 * v ^ (2 - 1)) * w) + 0.25 * w ^ 2 + 0.25 * ((2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * w) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + -0.25 * (u ^ 2 * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.25v + 0.25 * v ^ 2 + 0.25 * ((2 * w ^ (2 - 1)) * v) + 0.25 * (v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v) + -0.25 * (u ^ 2 * v ^ 2) + -0.25 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.25w + 0.25 * ((2 * u ^ (2 - 1)) * w) + -0.25 * w ^ 2 + 0.25 * ((2 * u ^ (2 - 1)) * w ^ 2) + 0.25 * (v ^ 2 * w) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.25 * (v ^ 2 * w ^ 2) + -0.25 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.25 * (u * (2 * v ^ (2 - 1)) * w) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.25 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + -0.25 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.25u + 0.25 * u ^ 2 + -0.25 * ((2 * w ^ (2 - 1)) * u) + 0.25 * (u ^ 2 * (2 * w ^ (2 - 1))) + 0.25 * (u * v ^ 2) + -0.25 * (u ^ 2 * v ^ 2) + 0.25 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + -0.25 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.5 * ((2 * u ^ (2 - 1)) * w) + -0.5 * ((2 * u ^ (2 - 1)) * w ^ 2) + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.5 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.5 * ((2 * v ^ (2 - 1)) * w) + -0.5 * ((2 * v ^ (2 - 1)) * w ^ 2) + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.5 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.5 + 0.5 * (2 * w ^ (2 - 1)) + 0.5 * u ^ 2 + 0.5 * v ^ 2 + -0.5 * (u ^ 2 * (2 * w ^ (2 - 1))) + -0.5 * (v ^ 2 * (2 * w ^ (2 - 1))) + -0.5 * (u ^ 2 * v ^ 2) + 0.5 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.5 * ((2 * u ^ (2 - 1)) * w) + -0.5 * ((2 * u ^ (2 - 1)) * w ^ 2) + 0.5 * ((2 * u ^ (2 - 1)) * v ^ 2 * w) + 0.5 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.5 * ((2 * v ^ (2 - 1)) * w) + -0.5 * ((2 * v ^ (2 - 1)) * w ^ 2) + 0.5 * (u ^ 2 * (2 * v ^ (2 - 1)) * w) + 0.5 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.5 + 0.5 * (2 * w ^ (2 - 1)) + -0.5 * u ^ 2 + -0.5 * v ^ 2 + -0.5 * (u ^ 2 * (2 * w ^ (2 - 1))) + -0.5 * (v ^ 2 * (2 * w ^ (2 - 1))) + 0.5 * (u ^ 2 * v ^ 2) + 0.5 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.5 * ((2 * u ^ (2 - 1)) * v) + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2) + -0.5 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + 0.5 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.5 + 0.5 * (2 * v ^ (2 - 1)) + 0.5 * u ^ 2 + 0.5 * w ^ 2 + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1))) + -0.5 * ((2 * v ^ (2 - 1)) * w ^ 2) + -0.5 * (u ^ 2 * w ^ 2) + 0.5 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.5 * ((2 * w ^ (2 - 1)) * v) + -0.5 * (v ^ 2 * (2 * w ^ (2 - 1))) + -0.5 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + 0.5 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0.5 + 0.5 * (2 * u ^ (2 - 1)) + -0.5 * v ^ 2 + -0.5 * w ^ 2 + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2) + -0.5 * ((2 * u ^ (2 - 1)) * w ^ 2) + 0.5 * (v ^ 2 * w ^ 2) + 0.5 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -0.5 * ((2 * v ^ (2 - 1)) * u) + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1))) + 0.5 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.5 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.5 * ((2 * w ^ (2 - 1)) * u) + -0.5 * (u ^ 2 * (2 * w ^ (2 - 1))) + 0.5 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.5 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.5 * ((2 * u ^ (2 - 1)) * v) + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2) + 0.5 * ((2 * u ^ (2 - 1)) * v * w ^ 2) + 0.5 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.5 + 0.5 * (2 * v ^ (2 - 1)) + -0.5 * u ^ 2 + -0.5 * w ^ 2 + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1))) + -0.5 * ((2 * v ^ (2 - 1)) * w ^ 2) + 0.5 * (u ^ 2 * w ^ 2) + 0.5 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -0.5 * ((2 * w ^ (2 - 1)) * v) + -0.5 * (v ^ 2 * (2 * w ^ (2 - 1))) + 0.5 * (u ^ 2 * v * (2 * w ^ (2 - 1))) + 0.5 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-0.5 + 0.5 * (2 * u ^ (2 - 1)) + 0.5 * v ^ 2 + 0.5 * w ^ 2 + -0.5 * ((2 * u ^ (2 - 1)) * v ^ 2) + -0.5 * ((2 * u ^ (2 - 1)) * w ^ 2) + -0.5 * (v ^ 2 * w ^ 2) + 0.5 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), 0.5 * ((2 * v ^ (2 - 1)) * u) + -0.5 * (u ^ 2 * (2 * v ^ (2 - 1))) + -0.5 * (u * (2 * v ^ (2 - 1)) * w ^ 2) + 0.5 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), 0.5 * ((2 * w ^ (2 - 1)) * u) + -0.5 * (u ^ 2 * (2 * w ^ (2 - 1))) + -0.5 * (u * v ^ 2 * (2 * w ^ (2 - 1))) + 0.5 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-1.0 * (2 * u ^ (2 - 1)) + (2 * u ^ (2 - 1)) * v ^ 2 + (2 * u ^ (2 - 1)) * w ^ 2 + -1.0 * ((2 * u ^ (2 - 1)) * v ^ 2 * w ^ 2), -1.0 * (2 * v ^ (2 - 1)) + u ^ 2 * (2 * v ^ (2 - 1)) + (2 * v ^ (2 - 1)) * w ^ 2 + -1.0 * (u ^ 2 * (2 * v ^ (2 - 1)) * w ^ 2), -1.0 * (2 * w ^ (2 - 1)) + u ^ 2 * (2 * w ^ (2 - 1)) + v ^ 2 * (2 * w ^ (2 - 1)) + -1.0 * (u ^ 2 * v ^ 2 * (2 * w ^ (2 - 1)))))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Pyr5: 5-node linear pyramid element
# ──────────────────────────────────────────────────────────────────────────────

    struct Pyr5Basis <: AbstractBasis{3}
            end
         Base.@pure function Base.size(::Type{Pyr5Basis})
                                    return (3, 5)
        end
        function Base.size(::Type{Pyr5Basis}, j::Int)
                        j == 1 && return 3
                j == 2 && return 5
    end
         Base.@pure function Base.length(::Type{Pyr5Basis})
                                    return 5
        end
        function get_reference_element_coordinates(::Type{Pyr5Basis})
                        return Vec{3, Float64}[[-1.0, -1.0, 0.0], [1.0, -1.0, 0.0], [1.0, 1.0, 0.0], [-1.0, 1.0, 0.0], [0.0, 0.0, 1.0]]
    end
         @inline function eval_basis!(::Type{Pyr5Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v, w) = xi
                         @inbounds return (0.25 + -0.25u + -0.25v + -0.25w + 0.25 * (u * v), 0.25 + 0.25u + -0.25v + -0.25w + -0.25 * (u * v), 0.25 + 0.25u + 0.25v + -0.25w + 0.25 * (u * v), 0.25 + -0.25u + 0.25v + -0.25w + -0.25 * (u * v), +w)
        end
         @inline function eval_dbasis!(::Type{Pyr5Basis}, xi::Vec)
                                    (u, v, w) = xi
                         @inbounds return (Vec(float.(tuple(-0.25 + 0.25v, -0.25 + 0.25u, -0.25))), Vec(float.(tuple(0.25 + -0.25v, -0.25 + -0.25u, -0.25))), Vec(float.(tuple(0.25 + 0.25v, 0.25 + 0.25u, -0.25))), Vec(float.(tuple(-0.25 + -0.25v, 0.25 + -0.25u, -0.25))), Vec(float.(tuple(0, 0, 1))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Wedge6: 6-node linear wedge element (triangular prism)
# ──────────────────────────────────────────────────────────────────────────────

    struct Wedge6Basis <: AbstractBasis{3}
            end
         Base.@pure function Base.size(::Type{Wedge6Basis})
                                    return (3, 6)
        end
        function Base.size(::Type{Wedge6Basis}, j::Int)
                        j == 1 && return 3
                j == 2 && return 6
    end
         Base.@pure function Base.length(::Type{Wedge6Basis})
                                    return 6
        end
        function get_reference_element_coordinates(::Type{Wedge6Basis})
                        return Vec{3, Float64}[[0.0, 0.0, -1.0], [1.0, 0.0, -1.0], [0.0, 1.0, -1.0], [0.0, 0.0, 1.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0]]
    end
         @inline function eval_basis!(::Type{Wedge6Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v, w) = xi
                         @inbounds return (0.5 + -0.5u + -0.5v + -0.5w + 0.5 * (u * w) + 0.5 * (v * w), 0.5u + -0.5 * (u * w), 0.5v + -0.5 * (v * w), 0.5 + -0.5u + -0.5v + 0.5w + -0.5 * (u * w) + -0.5 * (v * w), 0.5u + 0.5 * (u * w), 0.5v + 0.5 * (v * w))
        end
         @inline function eval_dbasis!(::Type{Wedge6Basis}, xi::Vec)
                                    (u, v, w) = xi
                         @inbounds return (Vec(float.(tuple(-0.5 + 0.5w, -0.5 + 0.5w, -0.5 + 0.5u + 0.5v))), Vec(float.(tuple(0.5 + -0.5w, 0, -0.5u))), Vec(float.(tuple(0, 0.5 + -0.5w, -0.5v))), Vec(float.(tuple(-0.5 + -0.5w, -0.5 + -0.5w, 0.5 + -0.5u + -0.5v))), Vec(float.(tuple(0.5 + 0.5w, 0, 0.5u))), Vec(float.(tuple(0, 0.5 + 0.5w, 0.5v))))
        end

# ──────────────────────────────────────────────────────────────────────────────
# Wedge15: 15-node quadratic wedge element
# ──────────────────────────────────────────────────────────────────────────────

    struct Wedge15Basis <: AbstractBasis{3}
            end
         Base.@pure function Base.size(::Type{Wedge15Basis})
                                    return (3, 15)
        end
        function Base.size(::Type{Wedge15Basis}, j::Int)
                        j == 1 && return 3
                j == 2 && return 15
    end
         Base.@pure function Base.length(::Type{Wedge15Basis})
                                    return 15
        end
        function get_reference_element_coordinates(::Type{Wedge15Basis})
                        return Vec{3, Float64}[[0.0, 0.0, -1.0], [1.0, 0.0, -1.0], [0.0, 1.0, -1.0], [0.0, 0.0, 1.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0], [0.5, 0.0, -1.0], [0.5, 0.5, -1.0], [0.0, 0.5, -1.0], [0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.5, 0.0, 1.0], [0.5, 0.5, 1.0], [0.0, 0.5, 1.0]]
    end
         @inline function eval_basis!(::Type{Wedge15Basis}, ::Type{T}, xi::Vec) where T
                                    (u, v, w) = xi
                         @inbounds return (-1.0u + -1.0v + -0.5w + u ^ 2 + v ^ 2 + 0.5 * w ^ 2 + 2.0 * (u * v) + 1.5 * (u * w) + 1.5 * (v * w) + -1.0 * (u ^ 2 * w) + -1.0 * (v ^ 2 * w) + -2.0 * (u * v * w) + -0.5 * (u * w ^ 2) + -0.5 * (v * w ^ 2), -1.0u + u ^ 2 + 0.5 * (u * w) + -1.0 * (u ^ 2 * w) + 0.5 * (u * w ^ 2), -1.0v + v ^ 2 + 0.5 * (v * w) + -1.0 * (v ^ 2 * w) + 0.5 * (v * w ^ 2), -1.0u + -1.0v + 0.5w + u ^ 2 + v ^ 2 + 0.5 * w ^ 2 + 2.0 * (u * v) + -1.5 * (u * w) + -1.5 * (v * w) + u ^ 2 * w + v ^ 2 * w + 2.0 * (u * v * w) + -0.5 * (u * w ^ 2) + -0.5 * (v * w ^ 2), -1.0u + u ^ 2 + -0.5 * (u * w) + u ^ 2 * w + 0.5 * (u * w ^ 2), -1.0v + v ^ 2 + -0.5 * (v * w) + v ^ 2 * w + 0.5 * (v * w ^ 2), 2.0u + -2.0 * u ^ 2 + -2.0 * (u * v) + -2.0 * (u * w) + 2.0 * (u ^ 2 * w) + 2.0 * (u * v * w), 2.0 * (u * v) + -2.0 * (u * v * w), 2.0v + -2.0 * v ^ 2 + -2.0 * (u * v) + -2.0 * (v * w) + 2.0 * (v ^ 2 * w) + 2.0 * (u * v * w), 1 + -1.0u + -1.0v + -1.0 * w ^ 2 + u * w ^ 2 + v * w ^ 2, u + -1.0 * (u * w ^ 2), v + -1.0 * (v * w ^ 2), 2.0u + -2.0 * u ^ 2 + -2.0 * (u * v) + 2.0 * (u * w) + -2.0 * (u ^ 2 * w) + -2.0 * (u * v * w), 2.0 * (u * v) + 2.0 * (u * v * w), 2.0v + -2.0 * v ^ 2 + -2.0 * (u * v) + 2.0 * (v * w) + -2.0 * (v ^ 2 * w) + -2.0 * (u * v * w))
        end
         @inline function eval_dbasis!(::Type{Wedge15Basis}, xi::Vec)
                                    (u, v, w) = xi
                         @inbounds return (Vec(float.(tuple(-1.0 + 2 * u ^ (2 - 1) + 2.0v + 1.5w + -1.0 * ((2 * u ^ (2 - 1)) * w) + -2.0 * (v * w) + -0.5 * w ^ 2, -1.0 + 2 * v ^ (2 - 1) + 2.0u + 1.5w + -1.0 * ((2 * v ^ (2 - 1)) * w) + -2.0 * (u * w) + -0.5 * w ^ 2, -0.5 + 0.5 * (2 * w ^ (2 - 1)) + 1.5u + 1.5v + -1.0 * u ^ 2 + -1.0 * v ^ 2 + -2.0 * (u * v) + -0.5 * (u * (2 * w ^ (2 - 1))) + -0.5 * (v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-1.0 + 2 * u ^ (2 - 1) + 0.5w + -1.0 * ((2 * u ^ (2 - 1)) * w) + 0.5 * w ^ 2, 0, 0.5u + -1.0 * u ^ 2 + 0.5 * (u * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0, -1.0 + 2 * v ^ (2 - 1) + 0.5w + -1.0 * ((2 * v ^ (2 - 1)) * w) + 0.5 * w ^ 2, 0.5v + -1.0 * v ^ 2 + 0.5 * (v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-1.0 + 2 * u ^ (2 - 1) + 2.0v + -1.5w + (2 * u ^ (2 - 1)) * w + 2.0 * (v * w) + -0.5 * w ^ 2, -1.0 + 2 * v ^ (2 - 1) + 2.0u + -1.5w + (2 * v ^ (2 - 1)) * w + 2.0 * (u * w) + -0.5 * w ^ 2, 0.5 + 0.5 * (2 * w ^ (2 - 1)) + -1.5u + -1.5v + u ^ 2 + v ^ 2 + 2.0 * (u * v) + -0.5 * (u * (2 * w ^ (2 - 1))) + -0.5 * (v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(-1.0 + 2 * u ^ (2 - 1) + -0.5w + (2 * u ^ (2 - 1)) * w + 0.5 * w ^ 2, 0, -0.5u + u ^ 2 + 0.5 * (u * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0, -1.0 + 2 * v ^ (2 - 1) + -0.5w + (2 * v ^ (2 - 1)) * w + 0.5 * w ^ 2, -0.5v + v ^ 2 + 0.5 * (v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(2.0 + -2.0 * (2 * u ^ (2 - 1)) + -2.0v + -2.0w + 2.0 * ((2 * u ^ (2 - 1)) * w) + 2.0 * (v * w), -2.0u + 2.0 * (u * w), -2.0u + 2.0 * u ^ 2 + 2.0 * (u * v)))), Vec(float.(tuple(2.0v + -2.0 * (v * w), 2.0u + -2.0 * (u * w), -2.0 * (u * v)))), Vec(float.(tuple(-2.0v + 2.0 * (v * w), 2.0 + -2.0 * (2 * v ^ (2 - 1)) + -2.0u + -2.0w + 2.0 * ((2 * v ^ (2 - 1)) * w) + 2.0 * (u * w), -2.0v + 2.0 * v ^ 2 + 2.0 * (u * v)))), Vec(float.(tuple(-1.0 + w ^ 2, -1.0 + w ^ 2, -1.0 * (2 * w ^ (2 - 1)) + u * (2 * w ^ (2 - 1)) + v * (2 * w ^ (2 - 1))))), Vec(float.(tuple(1 + -1.0 * w ^ 2, 0, -1.0 * (u * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(0, 1 + -1.0 * w ^ 2, -1.0 * (v * (2 * w ^ (2 - 1)))))), Vec(float.(tuple(2.0 + -2.0 * (2 * u ^ (2 - 1)) + -2.0v + 2.0w + -2.0 * ((2 * u ^ (2 - 1)) * w) + -2.0 * (v * w), -2.0u + -2.0 * (u * w), 2.0u + -2.0 * u ^ 2 + -2.0 * (u * v)))), Vec(float.(tuple(2.0v + 2.0 * (v * w), 2.0u + 2.0 * (u * w), 2.0 * (u * v)))), Vec(float.(tuple(-2.0v + -2.0 * (v * w), 2.0 + -2.0 * (2 * v ^ (2 - 1)) + -2.0u + 2.0w + -2.0 * ((2 * v ^ (2 - 1)) * w) + -2.0 * (u * w), 2.0v + -2.0 * v ^ 2 + -2.0 * (u * v)))))
        end

